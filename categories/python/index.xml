<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Colored Hedwig</title>
    <link>http://simonpatrick.github.io/categories/python/</link>
    <description>Recent content in Python on Colored Hedwig</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 28 Feb 2016 14:57:44 +0000</lastBuildDate>
    <atom:link href="http://simonpatrick.github.io/categories/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python 面向对象，以及访问对象属性基础</title>
      <link>http://simonpatrick.github.io/posts/python/2016-02-28-python_oop_attributes/</link>
      <pubDate>Sun, 28 Feb 2016 14:57:44 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2016-02-28-python_oop_attributes/</guid>
      <description>

&lt;p&gt;在前面的Zabbix API调用中我们看到了python的&lt;code&gt;__getattr__&lt;/code&gt;的妙用，下面就探索一下这里面的道理,所以就聊聊python面向对象的基础知识.&lt;/p&gt;

&lt;h2 id=&#34;python-面向对象:b78d674c6bd0e41530240ac276bacbc6&#34;&gt;Python 面向对象&lt;/h2&gt;

&lt;p&gt;说到面向对象，就会说到类(class)，对象(object),那么什么是Class，Object呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object：
Objects have states and behaviors. Example: A dog has states - color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class.&lt;/li&gt;
&lt;li&gt;Class:
A class can be defined as a template/blue print that describes the behaviors/states that object of its type support.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么综合起来，class就是用来描述一系列对象的一个模版，抽象出了共同的东西(class)，object就是具体的某种情况下的一个例子(instance)&lt;/p&gt;

&lt;p&gt;面向对象有如下基础概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Polymorphism&lt;/li&gt;
&lt;li&gt;Inheritance&lt;/li&gt;
&lt;li&gt;Encapsulation&lt;/li&gt;
&lt;li&gt;Abstraction&lt;/li&gt;
&lt;li&gt;Classes&lt;/li&gt;
&lt;li&gt;Objects&lt;/li&gt;
&lt;li&gt;Instance&lt;/li&gt;
&lt;li&gt;Method&lt;/li&gt;
&lt;li&gt;Message Parsing&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;python-class-and-object-的使用:b78d674c6bd0e41530240ac276bacbc6&#34;&gt;Python Class and Object 的使用&lt;/h2&gt;

&lt;p&gt;看下例：
- &lt;code&gt;class Dog&lt;/code&gt; 定义了一个类
- &lt;code&gt;__init__&lt;/code&gt; 构造这个类的方法，就是创建出一个Dog的对象是通过这个方法
- &lt;code&gt;name&lt;/code&gt;, 类的一个属性;&lt;code&gt;eat()&lt;/code&gt;,也可以看成是类的一个属性，实际上它是一个dog的一个行为(behavior)
- &lt;code&gt;dog = Dog()&lt;/code&gt; 是创建了一个Dog(class)的新的的对象(object), 按照我们上面说的，dog是类Dog(class)的一个实例(instance)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  class Dog:
    def __init__(self):
      self.name=&#39;dog&#39;

    def eat():
      print(&#39;eating......&#39;)

  dog = Dog()
  print(dog.name)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python-对象的创建:b78d674c6bd0e41530240ac276bacbc6&#34;&gt;Python 对象的创建&lt;/h2&gt;

&lt;p&gt;参考上例，分别来说明对象的创建，访问.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对象的访问&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  dog = Dog()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dog() 实际上创建了一个Dog的实例(object),那么他具体是通过Dog类的那个东西去实现的呢？是&lt;code&gt;__init__&lt;/code&gt; 方法实现的，可以通过下面的例子还看看：&lt;/p&gt;

&lt;p&gt;我们修改代码，就class Dog 中的&lt;code&gt;__init__&lt;/code&gt;方法去掉，然后运行代码看看&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;AttributeError: &#39;Dog&#39; object has no attribute &#39;name&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是运行后的一个错误，也就是说&lt;code&gt;name&lt;/code&gt;没有被初始化，远来的例子中name是通过&lt;code&gt;__init__&lt;/code&gt; 方法去初始化的，这也说明了实例的创建是通过&lt;code&gt;__init__&lt;/code&gt;来创建的.&lt;/p&gt;

&lt;p&gt;把&lt;code&gt;__init__&lt;/code&gt; 的修改还原，同时修改原有代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def __init__(self):
    self.name=&#39;dog&#39;
    print(&#39;Dog is created .....&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行代码，发现Dog is created&amp;hellip;&amp;hellip;输出了，所以使用&lt;code&gt;__init__&lt;/code&gt;的猜测是正确的.
不过我们进一步做一个尝试，去掉&lt;code&gt;__init__&lt;/code&gt;的代码，我们发现其实dog实例也是可以创建的，那么要问，没有&lt;code&gt;__init__&lt;/code&gt;也可以创建呀，那么如果类都是通过&lt;code&gt;__init__&lt;/code&gt;实例化的，那么这个时候怎么实例化的呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(Dog.__base__)
print(Dog.__bases__)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用如上的代码可以知道Dog的base class是object，也就是使用object的&lt;code&gt;__init__&lt;/code&gt;来实例话自己的.
到这里就简单的介绍了一下Python实例的创建.&lt;/p&gt;

&lt;h2 id=&#34;python-类实例的创建-继承:b78d674c6bd0e41530240ac276bacbc6&#34;&gt;Python 类实例的创建－ 继承&lt;/h2&gt;

&lt;p&gt;面向对象就逃不过继承，下面看看在继承的情况下，如何创建对象的.
好，那么久先创建继承一个Dog的一个类： CrazyDog():&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class CrazyDog(Dog):

    def why_crazy(self):
        print(&#39;I am sick.......&#39;)

crazy_dog = CrazyDog()
crazy_dog.eat()
print(crazy_dog.name)
crazy_dog.why_crazy()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是一个创建了一个CrazyDog的类，继承了Dog，python中继承就是在类声明语句的()中加入需要继承的类.运行上面的程序，可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Dog is created .....
eating .....
dog
I am sick.......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就更加清楚的看到了子类在没有定义&lt;code&gt;__init__&lt;/code&gt;的情况下，去使用了父类的&lt;code&gt;__init__&lt;/code&gt;方法.接下来我们尝试用自己的&lt;code&gt;__init__&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class CrazyDog(Dog):
  def __init__(self):
      super().__init__()
  def why_crazy(self):
      print(&#39;I am sick.......&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意使用super的写法哦，他需要调用&lt;strong&gt;init&lt;/strong&gt;方法的哦.重写后实际上我们是显性调用了父类的&lt;code&gt;__init__&lt;/code&gt;方法，同时可以完成自己写自己的&lt;code&gt;__init__&lt;/code&gt;方法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class CrazyDog(Dog):
    def __init__(self):
        self.is_crazy=True

    def why_crazy(self):
        print(&#39;I am sick.......&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行，报错，name不存在,&lt;code&gt;AttributeError: &#39;CrazyDog&#39; object has no attribute &#39;name&#39;&lt;/code&gt;, 哦，远来要使用父类的属性，是需要显性初始化父类的,修改成如下代码，一切就OK了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class CrazyDog(Dog):
    def __init__(self):
        super().__init__()
        self.is_crazy=True

    def why_crazy(self):
        print(&#39;I am sick.......&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python-访问对象中的属性:b78d674c6bd0e41530240ac276bacbc6&#34;&gt;Python 访问对象中的属性&lt;/h2&gt;

&lt;p&gt;上面例子中其实已经有如何访问对象的属性或者方法了，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;crazy_dog = CrazyDog()
crazy_dog.eat()
print(crazy_dog.name)
crazy_dog.why_crazy()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都非常容易理解，同时这里也可以看到，python的对象里面没有java的：&lt;code&gt;public,private,protected&lt;/code&gt;等定义来确定访问的范围.&lt;/p&gt;

&lt;h2 id=&#34;python-访问对象的属性-getattr-setattr:b78d674c6bd0e41530240ac276bacbc6&#34;&gt;Python 访问对象的属性： &lt;strong&gt;getattr&lt;/strong&gt;,&lt;strong&gt;setattr&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;继续再聊聊python的访问对象的属性，做个试验：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class CrazyDog(Dog):
    def __init__(self):
        super().__init__()
        self.is_crazy = True

    def why_crazy(self):
        print(&#39;I am sick.......&#39;)

    def __getattr__(self, item):
        print(&#39;getting attribute&#39;, item)
        return (item, &#39;getattr_created&#39;)
crazy_dog = CrazyDog()
crazy_dog.eat()
print(crazy_dog.name)
crazy_dog.why_crazy()
print(crazy_dog.name1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到如下结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Dog is created .....
eating .....
dog
I am sick.......
getting attribute name1
(&#39;name1&#39;, &#39;getattr_created&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子表明，如果访问没有定义变量名的时候，python是通过&lt;strong&gt;getattr&lt;/strong&gt;来访问的，未定义属性的赋值呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class CrazyDog(Dog):
  def __init__(self):
      super().__init__()
      self.is_crazy = True

  def why_crazy(self):
      print(&#39;I am sick.......&#39;)

  def __getattr__(self, item):
      print(&#39;getting attribute&#39;, item)
      return (item, &#39;getattr_created&#39;)

  def __setattr__(self, key, value):
      print(&#39;using setattr set value&#39;)
      print(key, value)
      super().__setattr__(key, value)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;crazy_dog = CrazyDog()
crazy_dog.eat()
print(crazy_dog.name)
crazy_dog.why_crazy()
crazy_dog.name2 = &#39;test_set_attr&#39;
print(crazy_dog.name1)
print(crazy_dog.name2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果&lt;code&gt;crazy_dog.name2&lt;/code&gt;是test_set_attr, 这个例子清楚的表明，没有定义的属性变量是通过&lt;code&gt;__setattr__&lt;/code&gt;去访问的，如果我们修改原有的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# super().__setattr__(key, value) 修改到如下的代码：
setattr(self,key,value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行，我们会发现递归深度不够的错误，所以这个地方我们需要使用&lt;code&gt;super().__setattr__(k,v)&lt;/code&gt;来处理, 那么为什么呢？
我自己推测是setattr(self,k,v)是使用了self的&lt;strong&gt;setattr&lt;/strong&gt;,那么很明显这个就是死循环了，因为他具体到了self这个实例，如果改为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;setattr(Dog,key,value)
setattr(CrazyDog,key,value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;都可以成功，相信这里面python语言再lookup method的时候有一套自己的方法.&lt;/p&gt;

&lt;p&gt;回顾一下这个&lt;strong&gt;getattr&lt;/strong&gt;,_setattr__ 两个方法，可以动态创建属性，这个机制会减少不少的代码量.和java比起来会减少很多的反射的代码.&lt;/p&gt;

&lt;p&gt;这块内容需要继续学习和挖掘！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simple Word Counter</title>
      <link>http://simonpatrick.github.io/posts/python/2016-02-28-simple_word_count/</link>
      <pubDate>Sun, 28 Feb 2016 10:41:15 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2016-02-28-simple_word_count/</guid>
      <description>

&lt;p&gt;有时测试的面试题中会考点编程的内容，比如统计字符串中的相同字符数量，具体题目如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;给定一个字符串，如MIssissippi&lt;/li&gt;
&lt;li&gt;计算字符串中每一个不同字符出现的数量&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;python-的解法:e6c4d79ca6914cdb5de91af5f8b312d6&#34;&gt;Python 的解法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;letter_count={}
for letter in &#39;MIssissippi&#39;:
  letter[letter]=letter_count.get(letter,0)+1
print(letter_count)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&#39;s&#39;: 4, &#39;M&#39;: 1, &#39;i&#39;: 3, &#39;I&#39;: 1, &#39;p&#39;: 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;java-的解法:e6c4d79ca6914cdb5de91af5f8b312d6&#34;&gt;Java 的解法&lt;/h2&gt;

&lt;p&gt;JAVA 8 中给Map加入了getOrDefault的方法，下面就分别介绍一下JAVA8之前和使用JAVA8的方法：&lt;/p&gt;

&lt;h3 id=&#34;java8-之前:e6c4d79ca6914cdb5de91af5f8b312d6&#34;&gt;JAVA8 之前：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Map&amp;lt;String,Integer&amp;gt; countCharacters(String source){
       char[] chars = source.toCharArray();
       Map&amp;lt;String,Integer&amp;gt; result = new HashMap&amp;lt;&amp;gt;();

       for (char aChar : chars) {
           Integer existing_counter = result.get(String.valueOf(aChar));
           int counter =  existing_counter==null?0:existing_counter;
           result.put(String.valueOf(aChar),counter+1);
       }
       return result;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;java8-解法:e6c4d79ca6914cdb5de91af5f8b312d6&#34;&gt;JAVA8 解法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public Map&amp;lt;String,Integer&amp;gt; countCharacters_JAVA8(String source){
    char[] chars = source.toCharArray();
    Map&amp;lt;String,Integer&amp;gt; result = new HashMap&amp;lt;&amp;gt;();
    for (char aChar : chars) {
        result.put(String.valueOf(aChar),result.getOrDefault(String.valueOf(aChar),0)+1);
    }
    return result;
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Python 访问Zabbix API</title>
      <link>http://simonpatrick.github.io/posts/python/2016-02-26-call_zabbix_api/</link>
      <pubDate>Fri, 26 Feb 2016 16:51:20 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2016-02-26-call_zabbix_api/</guid>
      <description>

&lt;h2 id=&#34;zabbix-api-访问:cf643a9d1d4340cbb976b94011be6da5&#34;&gt;Zabbix API 访问&lt;/h2&gt;

&lt;p&gt;准备使用Python来访问一下Zabbix，首先当然阅读一下Zabbix的&lt;a href=&#34;https://www.zabbix.com/documentation/2.4/&#34;&gt;API Manual&lt;/a&gt;,抛开什么json rpc这样的问题之外，zabbix的API的分类还是很工整的，所以看起来比较舒服，在一定了解了zabbix基础之后，基本上就可以上手来写了，网上查了一下，找个一个python zabbix的调用的一个客户段代码，感觉不错，就开始行动了。&lt;/p&gt;

&lt;h2 id=&#34;zabbix-api-客户端代码的实现:cf643a9d1d4340cbb976b94011be6da5&#34;&gt;Zabbix API 客户端代码的实现&lt;/h2&gt;

&lt;p&gt;Zabbix API的主要的两个参数其实是method，params，params基本上就可以看作一些可变的参数，其实就是一个json或者map， 对于method来说，一般就是 resource.action 这种方式，所以python客户端使用重写了一个&lt;strong&gt;getattr&lt;/strong&gt;来做,返回一个可以访问不同资源名称的客户端,具体的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ZabbixClient:
    &amp;quot;&amp;quot;&amp;quot;
    Generic Zabbix API Client
    - login
    - get auth
    &amp;quot;&amp;quot;&amp;quot;
    globale_header = {
        &amp;quot;Content-Type&amp;quot;: &amp;quot;application/json-rpc&amp;quot;
    }

    def __init__(self, session=None, timeout=None):
        self.user_name, self.default_user_name = &#39;1&#39;, &#39;1&#39;
        self.password, self.default_password = &#39;123456&#39;, &#39;123456&#39;
        self.zabbix_api_url = &#39;http://{0}/api_jsonrpc.php&#39;.format(&#39;abcd.http&#39;)
        if session:
            self.session = session
        else:
            self.session = requests.session()

        self.session.headers.update({
            &#39;Content-Type&#39;: &#39;application/json-rpc&#39;,
            &#39;User-Agent&#39;: &#39;python-zabbix-client&#39;,
            &#39;Cache-Control&#39;: &#39;no-cache&#39;
        })

        self.auth = &#39;&#39;
        self.id = 0
        self.timeout = timeout
        logger.info(&#39;JSON-RPC Server EndPoint: %s&#39;, self.zabbix_api_url)

    def login_in(self, user_name=None, password=None):
        &amp;quot;&amp;quot;&amp;quot;
        login with given user_name and password, if None, use default user
        :param user_name:
        :param password:
        :return: result,auth key
        &amp;quot;&amp;quot;&amp;quot;
        if user_name:
            self.user_name = user_name

        if password:
            self.password = password

        self.auth = self.user.login(user=self.user_name, password=self.password)

    def api_version(self):
        return self.apiinfo.version()

    # def confimport(self, format=&#39;&#39;, source=&#39;&#39;, rules=&#39;&#39;):
    #     &amp;quot;&amp;quot;&amp;quot;Alias for configuration.import because it clashes with
    #        Python&#39;s import reserved keyword&amp;quot;&amp;quot;&amp;quot;
    #
    #     return self.do_request(
    #         method=&amp;quot;configuration.import&amp;quot;,
    #         params={&amp;quot;format&amp;quot;: format, &amp;quot;source&amp;quot;: source, &amp;quot;rules&amp;quot;: rules}
    #     )[&#39;result&#39;]

    def do_request(self, method, params=None):
        request_json = {
            &#39;jsonrpc&#39;: &#39;2.0&#39;,
            &#39;method&#39;: method,
            &#39;params&#39;: params or {},
            &#39;id&#39;: self.id,
        }

        if method != &#39;apiinfo.version&#39; and self.auth:
            request_json[&#39;auth&#39;] = self.auth

        logger.debug(&amp;quot;sending: %s&amp;quot;, json.dumps(request_json, indent=4, separators=(&#39;,&#39;, &#39;:&#39;)))
        response = self.session.post(
            self.zabbix_api_url,
            data=json.dumps(request_json),
            timeout=self.timeout
        )
        logger.debug(&amp;quot;Response Code : %s&amp;quot;, str(response.status_code))

        response.raise_for_status()

        if not len(response.text):
            raise ZabbixAPIException(&amp;quot;没有返回值&amp;quot;)

        try:
            response_json = json.loads(response.text)
        except ValueError:
            raise ZabbixAPIException(&amp;quot;不能解析JSON %s&amp;quot; % response.text)

        logger.debug(&amp;quot;sending: %s&amp;quot;, json.dumps(request_json, indent=4, separators=(&#39;,&#39;, &#39;:&#39;)))

        self.id += 1

        if &#39;error&#39; in response_json:
            if &#39;data&#39; not in response_json[&#39;error&#39;]:
                response_json[&#39;error&#39;][&#39;data&#39;] = &#39;No Data&#39;
            msg = &amp;quot;Error {code}: {message},{data}&amp;quot;.format(
                code=response_json[&#39;error&#39;][&#39;code&#39;],
                message=response_json[&#39;error&#39;][&#39;message&#39;],
                data=response_json[&#39;error&#39;][&#39;data&#39;]
            )
            raise ZabbixAPIException(msg, response_json[&#39;error&#39;][&#39;code&#39;])

        return response_json

    def __getattr__(self, item):
        &amp;quot;&amp;quot;&amp;quot;
        auto create Zabbix API Client
        :param item:
        :return:
        &amp;quot;&amp;quot;&amp;quot;
        return ZabbixAPIObjectClass(item, self)


class ZabbixAPIObjectClass(object):
    def __init__(self, name, parent):
        self.name = name
        self.parent = parent

    def __getattr__(self, item):

        &amp;quot;&amp;quot;&amp;quot;
        dynamic create a method (get,create,update,delete)
        :param item:
        :return:
        &amp;quot;&amp;quot;&amp;quot;

        def fn(*args, **kwargs):
            if args and kwargs:
                raise TypeError(&#39;Found Both args and kwargs&#39;)

            return self.parent.do_request(&#39;{0}.{1}&#39;.format(self.name, item),
                                          args or kwargs)[&#39;result&#39;]

        return fn

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本上一个文件就搞定了，不过这个基本上参考了网上的一个代码实现的，这里使用&lt;strong&gt;getattr&lt;/strong&gt;这种方式可以非常简洁的处理了这种请求非常类似的情况，这也是python的魅力吧.&lt;/p&gt;

&lt;h2 id=&#34;访问zabbix-api:cf643a9d1d4340cbb976b94011be6da5&#34;&gt;访问Zabbix API&lt;/h2&gt;

&lt;p&gt;访问API比较简单(如何参数不多的话，哈哈)，实例代码取Template的一些信息如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class TestZabbixTemplateClient(unittest.TestCase):

    def setUp(self):
        self.zapi = ZabbixClient()
        self.zapi.login_in()

    def test_get_template(self):
        templates = self.zapi.template.get()
        print(templates)

    def test_get_template(self):
        templates = self.zapi.template.get(
            filter={
                &amp;quot;host&amp;quot;: [&amp;quot;Template OS Linux&amp;quot;]
            })
        print(templates[0][&amp;quot;id&amp;quot;])

    def test_create_template(self):
        template = self.zapi.template.create()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;补充一句，就是其实可以看到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ZabbixClient这个类没有定义template，可是他去可以使用？写了JAVA人是不是感觉有点惊喜的感觉&lt;/li&gt;
&lt;li&gt;template也没有create这个方法呀，他是怎么做到的？？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个例子很好的说明了使用&lt;code&gt;__getattr__&lt;/code&gt;可以做一些魔法的事情&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>zabbix 基础</title>
      <link>http://simonpatrick.github.io/posts/python/2016-02-26-zabbix_monitoring/</link>
      <pubDate>Fri, 26 Feb 2016 16:48:54 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2016-02-26-zabbix_monitoring/</guid>
      <description>

&lt;p&gt;抽空花了1个小时看了一下Zabbix的界面和简单的手册，了解了一下Zabbix的基础知识，下面是一个小小的记录,后面就写一些Python的脚本来直接调用Zabbix的API在进行一些自动化的操作.&lt;/p&gt;

&lt;h1 id=&#34;zabbix-基础:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Zabbix 基础&lt;/h1&gt;

&lt;p&gt;Zabbix 是一个开源的监控系统，由于需要帮助运维写一些调用ZABBIX API的代码，所以就开始了解一下ZABBIX的一些基本概念. 简单的看了一下Zabbix的一个手册，大致了解Zabbix监控的一些概念，以下是Zabbix中比较重要的概念或者可以认为一些抽象的实体资源:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Configuration&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HOST&lt;/li&gt;
&lt;li&gt;HOST GROUP&lt;/li&gt;
&lt;li&gt;Templates&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Monitor&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Application&lt;/li&gt;
&lt;li&gt;Items: keys&lt;/li&gt;
&lt;li&gt;Triggers&lt;/li&gt;
&lt;li&gt;Graphs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;configuration-host:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Configuration:HOST&lt;/h2&gt;

&lt;p&gt;HOST 就是Zabbix监控的对象，创建HOST可以通过一些预先定义好的模版来实现.
以Linux Group来说的话，HOST可能还有以下的一些属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Agent Interface&lt;/li&gt;
&lt;li&gt;SNMP Interface&lt;/li&gt;
&lt;li&gt;JMX Interface&lt;/li&gt;
&lt;li&gt;IPMI Interface&lt;/li&gt;
&lt;li&gt;Monitory proxy&lt;/li&gt;
&lt;li&gt;Status&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;configuration-host-group:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Configuration: HOST GROUP&lt;/h2&gt;

&lt;p&gt;创建HOST的同时可以创建一个HOST GROUP，HOST GROUP实际上就是不同的HOST组合起来成一组.&lt;/p&gt;

&lt;h2 id=&#34;configuration-templates:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Configuration: Templates&lt;/h2&gt;

&lt;p&gt;Templates 就是一些HOST的模版，相似的HOST可以通过模版继承，组合的方式创建&lt;/p&gt;

&lt;h2 id=&#34;monitor:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Monitor&lt;/h2&gt;

&lt;p&gt;从监控的层级来看，监控HOST的层级逻辑是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HOSTGROUP: HOST GROUP是可以认为不同HOST的容器&lt;/li&gt;
&lt;li&gt;HOST: 监控的实体,监控的实体实际上有不同的监控模版组合而成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下的APPLICATION，ITEM,TRIGGER,Graph 其实都是继承了模版的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;APPLICATION,可以认为是一组监控的内容&lt;/li&gt;
&lt;li&gt;ITEM: item就是监控的具体的一个数值,比如&lt;code&gt;cl Loaded Class Count&lt;/code&gt;他的key是&lt;code&gt;jmx[&amp;quot;java.lang:type=ClassLoading&amp;quot;,LoadedClassCount]&lt;/code&gt;
这个ITEM就是具体监控LoadedClass数目的一项，那么多个项目就可以组合成一个Application，ITEM 其实可以认为是采样数据的一个项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个Template可以通过多个Application来组合而成，一个Application可以由Items来组合而成，一个HOST包含有多个监控的Template，一个HOST Group可以有多个HOST.&lt;/p&gt;

&lt;p&gt;关于TEMPLATE的继承关系是： HOST 继承HOST GROUP的TEMPLATE&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Graph： 图表&lt;/li&gt;
&lt;li&gt;Trigger： 触发器
这两个可以设置到模版级别的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;monitor-application:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Monitor: Application&lt;/h2&gt;

&lt;p&gt;Application 可以认为是监控的一个大的项目，里面可能包括了不同的采样项目(item)
create Application，可以参考一下API文档就可以&lt;/p&gt;

&lt;h2 id=&#34;monitor-item:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Monitor: Item&lt;/h2&gt;

&lt;p&gt;Item创建首先需要创建一个key(在创建KEY之前可以先创建一个TEMPLATE)，key 相当于需要监控什么，如何设置？
- 监控客户端设置, 在zabbix_agentd.conf中需要添加UserParameter&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;  grep -v &#39;#&#39; /etc/zabbix/zabbix_agentd.conf|grep -v &amp;quot;^$&amp;quot;
  export UserParameter=&amp;lt;key_name&amp;gt;,&amp;lt;shell_command&amp;gt; &amp;gt;&amp;gt;  &amp;lt;configure_file_location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ITEM的设置，可以设置ITEM的类型，同时使用一些表达是来完成需要的采样内容的设置&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;graphs:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Graphs&lt;/h2&gt;

&lt;p&gt;graph 就是图标，那么很明显，一个graph有x,y 轴，x轴一般总是时间序列，另外一个轴对应不同的item（采样项目），同时又一些graph的类型选择，以及图表大小的设置&lt;/p&gt;

&lt;h2 id=&#34;triggers:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Triggers&lt;/h2&gt;

&lt;p&gt;Trigger 就是一个触发器，对于单独的一个item来说，如果设置了一些阀值,那么如果超过这个阀值，那么就会报警了.&lt;/p&gt;

&lt;p&gt;这是Zabbix的一些基本概念，其他还有如：
- Action, 遇到问题进行的操作
- Screens: 多个Graph就组合成一个Screen
- Slideshow: 多个Screen可以轮播
- Map: 网络路径图
- Discovery Rule: 发现安装Zabbix Agent的机器的规则
- 其他：如一些各种interface的设置，大致有个了结，可能在后续中会使用&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python yaml 使用介绍</title>
      <link>http://simonpatrick.github.io/posts/python/2016-02-13-python-yaml/</link>
      <pubDate>Sat, 13 Feb 2016 18:38:43 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2016-02-13-python-yaml/</guid>
      <description>

&lt;h1 id=&#34;python-yaml-应用:3b71fa4aa27b698fdcd613a231439d69&#34;&gt;Python YAML 应用&lt;/h1&gt;

&lt;p&gt;YAML由于其可读性，越来越多的地方用它来做配置文件了来代替XML文件.下面就是用来介绍如何使用PYTHON来进行YAML的操作.
读取yaml或者写yaml，主要是用的是两个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;load 读&lt;/li&gt;
&lt;li&gt;dump 写&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;read-yaml-to-list:3b71fa4aa27b698fdcd613a231439d69&#34;&gt;Read YAML to List&lt;/h2&gt;

&lt;p&gt;以下是读YAML 内容到python的list&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PYTHON&#34;&gt;import yaml
def load_list():
    content = &amp;quot;&amp;quot;&amp;quot;
        - config
        - domain
        - repository
    &amp;quot;&amp;quot;&amp;quot;
    return yaml.load(content)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;read-yaml-to-dict:3b71fa4aa27b698fdcd613a231439d69&#34;&gt;Read YAML TO DICT&lt;/h2&gt;

&lt;p&gt;load yaml to dict or a nest dict:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import yaml

def load_dict():
  content = &amp;quot;&amp;quot;&amp;quot;
      hello1: test
      hello2: test2
  &amp;quot;&amp;quot;&amp;quot;
  return yaml.load(content)


def load_all_dict():
  contents = &amp;quot;&amp;quot;&amp;quot;
    hero:
      hp: 34
      sp: 8
      level: 4
    orc:
      hp: 12
      sp: 0
      level: 2
  &amp;quot;&amp;quot;&amp;quot;
  return yaml.load(contents)

print(load_dict())
print(load_all_dict())
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;read-yaml-auto-type-conversation:3b71fa4aa27b698fdcd613a231439d69&#34;&gt;Read YAML: auto type conversation&lt;/h2&gt;

&lt;p&gt;yaml 对于格式要求比较严格的，： 后面注意加空格，同时python的原始类型通过load函数可以自动转化的.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import yaml

def load_with_type():
    contents = &amp;quot;&amp;quot;&amp;quot;
        none: [~,null]
        bool: [true,false,on,off]
        int: 42
        float: 3.1415
        list: [test1,test2,test3]
        dict: {name: simon,sp: 5}
    &amp;quot;&amp;quot;&amp;quot;

    return yaml.load(contents)

print(load_with_type())

## result:
{&#39;dict&#39;: {&#39;name&#39;: &#39;simon&#39;, &#39;sp&#39;: 5}, &#39;none&#39;: [None, None], &#39;int&#39;: 42, &#39;bool&#39;: [True, False, True, False], &#39;list&#39;: [&#39;test1&#39;, &#39;test2&#39;, &#39;test3&#39;], &#39;float&#39;: 3.1415}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dump-yaml-write-contents-to-a-yml-file:3b71fa4aa27b698fdcd613a231439d69&#34;&gt;Dump YAML: write contents to a yml file&lt;/h2&gt;

&lt;p&gt;使用dump函数直接可以将dict 内容写入到yml文件，这里有两个参数：
- default_flow_style: 设为false之后就&lt;code&gt;first_name: simon&lt;/code&gt; 这种格式了
- default_style: 设为‘“’, first_name 就会加上“”&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def dump_file():
    contents = {
        &#39;name&#39;: &#39;test&#39;,
        &#39;first_name&#39;: &#39;simon&#39;,
        &#39;last_name&#39;: &#39;kevin&#39;
    }
    # return yaml.dump(contents)
    with open(&#39;document.yaml&#39;, &#39;w&#39;) as f:
        return yaml.dump(contents, f, default_flow_style=False, default_style=&#39;&amp;quot;&#39;)

# file result:
&amp;quot;first_name&amp;quot;: &amp;quot;simon&amp;quot;
&amp;quot;last_name&amp;quot;: &amp;quot;kevin&amp;quot;
&amp;quot;name&amp;quot;: &amp;quot;test&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂一点的yaml格式:3b71fa4aa27b698fdcd613a231439d69&#34;&gt;复杂一点的YAML格式&lt;/h2&gt;

&lt;p&gt;下面一个yaml文件表示了一个JAVA maven项目里面主要的一些目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;      main:
        - config
        - domain
        - repository
        - service
        - rest:
          - controller
          - dto
          - exception
        - exceptions
        - utils
      resources:
        - config
      test:
        - config
        - domain
        - repository
        - service
        - rest:
          - controller
          - dto
          - exception
        - exceptions
        - utils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读取此文件的python代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def read_yaml_file():
    with open(&#39;springboot-folders.yml&#39;, &#39;r&#39;) as f:
        result = yaml.load(f)

    return result
folders = read_yaml_file()
print(folders[&#39;main&#39;])
print(folders[&#39;test&#39;])
print(folders[&#39;resources&#39;])

# result:
[&#39;config&#39;, &#39;domain&#39;, &#39;repository&#39;, &#39;service&#39;, {&#39;rest&#39;: [&#39;controller&#39;, &#39;dto&#39;, &#39;exception&#39;]}, &#39;exceptions&#39;, &#39;utils&#39;]
[&#39;config&#39;, &#39;domain&#39;, &#39;repository&#39;, &#39;service&#39;, {&#39;rest&#39;: [&#39;controller&#39;, &#39;dto&#39;, &#39;exception&#39;]}, &#39;exceptions&#39;, &#39;utils&#39;]
[&#39;config&#39;]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上已经非常清楚的表示了如何读取yml文件了， 至此简单的yml的使用介绍就到此为止. 更加详细的介绍请参考：
&lt;a href=&#34;http://pyyaml.org/wiki/PyYAMLDocumentation&#34;&gt;python yaml&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ptyhon design pattern: chain of responsibility</title>
      <link>http://simonpatrick.github.io/posts/designpattern/2016-01-11-ptyhon-design-pattern-chain/</link>
      <pubDate>Mon, 11 Jan 2016 23:35:45 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/designpattern/2016-01-11-ptyhon-design-pattern-chain/</guid>
      <description>&lt;p&gt;python 的责任链模式.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;方法链：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上代码吧： 其实就死return 了一个self，java里面可能是this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Person(object):
    def __init__(self, name, action):
        self.name = name
        self.action = action

    def do_action(self):
        print(self.name, self.action.name, end=&#39; &#39;)
        return self.action


class Action(object):
    def __init__(self, name):
        self.name = name

    def amount(self, val):
        print(val, end=&#39; &#39;)
        return self

    def stop(self):
        print(&#39;then stop&#39;)


if __name__ == &#39;__main__&#39;:
    move = Action(&#39;move&#39;)
    person=Person(&#39;Jack&#39;,move)
    person.do_action().amount(&#39;5m&#39;).stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;责任链:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是一个责任链的模式，一个handler叠加，下例中：
ConcreteHandler1-&amp;gt;ConcreteHandler3-&amp;gt;ConcreteHandler2-&amp;gt;DefaultHandler,
那么如果第一个request满足了ConcreteHandler1的条件，就结束了，如果没有怎尝试ConcreteHandler3，知道满足了就退出.
这样就把一大批if else 转化成不同的handler了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Handler:
    def __init__(self, successor):
        self._successor = successor;

    def handle(self, request):
        i = self._handle(request)
        if not i:
            self._successor.handle(request)

    def _handle(self, request):
        raise NotImplementedError(&#39;Must provide implementation in subclass.&#39;)


class ConcreteHandler1(Handler):
    def _handle(self, request):
        if 0 &amp;lt; request &amp;lt;= 10:
            print(&#39;request {} handled in handler 1&#39;.format(request))
            return True


class ConcreteHandler2(Handler):
    def _handle(self, request):
        if 10 &amp;lt; request &amp;lt;= 20:
            print(&#39;request {} handled in handler 2&#39;.format(request))
            return True


class ConcreteHandler3(Handler):
    def _handle(self, request):
        if 20 &amp;lt; request &amp;lt;= 30:
            print(&#39;request {} handled in handler 3&#39;.format(request))
            return True


class DefaultHandler(Handler):
    def _handle(self, request):
        print(&#39;end of chain, no handler for {}&#39;.format(request))
        return True


class Client:
    def __init__(self):
        self.handler = ConcreteHandler1(ConcreteHandler3(ConcreteHandler2(DefaultHandler(None))))

    def delegate(self, requests):
        for request in requests:
            self.handler.handle(request)


if __name__ == &amp;quot;__main__&amp;quot;:
    client = Client()
    requests = [2, 5, 14, 22, 18, 3, 35, 27, 20]
    client.delegate(requests)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>python-borg-design-pattern</title>
      <link>http://simonpatrick.github.io/posts/designpattern/2016-01-11-python-design-pattern-borg/</link>
      <pubDate>Mon, 11 Jan 2016 23:05:26 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/designpattern/2016-01-11-python-design-pattern-borg/</guid>
      <description>

&lt;p&gt;Python Design Pattern: Borg&lt;/p&gt;

&lt;h2 id=&#34;borg:55f4fe74eecacc8a05b13cb7793b0531&#34;&gt;Borg&lt;/h2&gt;

&lt;p&gt;Borg 模式实际上就是一个类的多个实例共享一个相同的状态.
简单的代码实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;__author__ = &#39;patrick&#39;


class Borg:
    _share_state = {}

    def __init__(self):
        self.__dict__ = self._share_state
        self.state = &#39;Init&#39;

    def __str__(self):
        return self.state


class YourBorg(Borg):
    pass


if __name__ == &#39;__main__&#39;:
    rm1 = Borg()
    rm2 = Borg()
    rm1.state = &#39;Idle&#39;
    rm2.state = &#39;Running&#39;

    print(&#39;rm1: {0}&#39;.format(rm1))
    print(&#39;rm2: {0}&#39;.format(rm2))

    rm2.state = &#39;Zombie&#39;

    print(&#39;rm1: {0}&#39;.format(rm1))
    print(&#39;rm2: {0}&#39;.format(rm2))

    print(&#39;rm1 id: {0}&#39;.format(id(rm1)))
    print(&#39;rm2 id: {0}&#39;.format(id(rm2)))

    rm3 = YourBorg()

    print(&#39;rm1: {0}&#39;.format(rm1))
    print(&#39;rm2: {0}&#39;.format(rm2))
    print(&#39;rm3: {0}&#39;.format(rm3))

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Python 中String的格式化</title>
      <link>http://simonpatrick.github.io/posts/python/2015-11-15-String-Format-in-Python/</link>
      <pubDate>Sun, 15 Nov 2015 15:12:56 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2015-11-15-String-Format-in-Python/</guid>
      <description>

&lt;p&gt;python中对于string有些挺有意思操作,现在把他记录如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;output = &#39;Hello {0}!&#39;.format(&#39;World!&#39;)
output1 = &#39;Hello {0} {1} !&#39;.format(&#39;Mr.&#39;,&#39;World!&#39;)
output2 = &#39;Hello {name} !&#39;.format(name=&#39;World&#39;)


print(output)
print(output1)
print(output2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上可读性最好的，个人认为是:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;output2 = &#39;Hello {name} !&#39;.format(name=&#39;World&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;时间-urlparser的一起使用:6ee2730f87b96f11ff90ec9ef3507537&#34;&gt;时间，urlparser的一起使用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(&#39;It\&#39;s {0:%H:%M}&#39;.format(datetime.today()))
url = urlparse(&#39;http://pocoo.org/&#39;)
print(&#39;{0.netloc} [{0.scheme}]&#39;.format(url))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;It&#39;s 15:16
pocoo.org [http]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是很方便的.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python完成简单的SVN Reviewboard Precommit的客户端</title>
      <link>http://simonpatrick.github.io/posts/python/2015-05-16-svn_reviewboard_python/</link>
      <pubDate>Sat, 16 May 2015 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2015-05-16-svn_reviewboard_python/</guid>
      <description>

&lt;p&gt;最近公司需要使用review board进行代码pre-commit review(pre-commit:正式提交前review)，而公司的现状是：
1. 使用SVN作为代码版本管理工具
2. 开发工具有eclipse，idea
3. MAC 和windows 机器居多&lt;/p&gt;

&lt;p&gt;考虑到开发eclipse和idea插件，连接review board我一个人无法完成，同时能力也不够来开发这两种插件，
所以就准备python写一个命令行工具，期间研究了一下taobao review board的插件，感觉有点复杂，这个也是
使用python来些命令行工具的一个理由,也考虑过使用node-webkit来写个客户端，不过由于时间上的限制也就先放弃了&lt;/p&gt;

&lt;h2 id=&#34;实现:9c8e3f625c3962072302f48860331be5&#34;&gt;实现&lt;/h2&gt;

&lt;p&gt;实现过程中，使用到主要的包和工具是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;RBTools,review board 自带的工具，但是支持中文能力让人有点困惑&lt;/li&gt;
&lt;li&gt;python，cmd 包(python自带)，requests包使用 pip install requests 安装&lt;/li&gt;
&lt;li&gt;ConEmuPack(windows CMD的替代),主要为了支持window系统&lt;/li&gt;
&lt;li&gt;SVN&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后实现了如下功能
- 选择更改的文件，提交Review Board 作为pre-commit review
- 根据review request id 提交代码到SVN
- python直接操作svn命令,可以通过简单的命令就提交代码(由于使用习惯的问题,个人觉得命令行比UI效率更高)
  svn命令有个问题就是如果操作delete或者add这种的话,如果文件没有直接放到svn work copy的话,提交需要两步操作,
  而这个工具也解决了这个问题&lt;/p&gt;

&lt;h2 id=&#34;review-board-功能介绍:9c8e3f625c3962072302f48860331be5&#34;&gt;Review Board 功能介绍&lt;/h2&gt;

&lt;p&gt;review board 是进行代码review的一个工具，目前公司主要用来做pre-commit的review，在review board针对pre-主要有如下概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;review request draft, draft里面包含了differ文件，描述，review的人等等&lt;/li&gt;
&lt;li&gt;review request，在这个review request上面review&lt;/li&gt;
&lt;li&gt;review完毕，才可以提交代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装和配置:9c8e3f625c3962072302f48860331be5&#34;&gt;安装和配置&lt;/h2&gt;

&lt;h3 id=&#34;1-安装python-和requests包:9c8e3f625c3962072302f48860331be5&#34;&gt;1.安装Python 和Requests包&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;下载安装最新版本的Python，确保在命令行中可以执行Python命令，如果打开命令行工具，执行python -v 失败，需要在环境变量中设置Python的执行路径&lt;/li&gt;
&lt;li&gt;安装Python完成之后，在命令行中执行&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pip install requests
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装requests包到全局。MAC可能需要使用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo pip install requests
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-安装rbtools:9c8e3f625c3962072302f48860331be5&#34;&gt;2. 安装RBTools&lt;/h3&gt;

&lt;p&gt;下载安装RBTool,RBTool有不同操作系统对应的版本，根据自身操作系统下载并安装，MAC和windows都是可执行文件，一路next就可以
安装完毕，在命令行检查是否安装成功:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt; rbt -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检查版本，如果有版本显示则成功&lt;/p&gt;

&lt;h3 id=&#34;3-配置svn:9c8e3f625c3962072302f48860331be5&#34;&gt;3. 配置SVN&lt;/h3&gt;

&lt;p&gt;配置SVN，MAC自带了SVN，Windows需要将SVN，配置到环境变量里面，具体方法如下,命令行中执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;	svn --version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果返回版本信息，则忽略下面步骤:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;下载SVN BIN文件，将BIN目录配置到环境变量PATH下面，命令行中执行svn --version如果返回版本信息则成功
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-windows-下载comemupack:9c8e3f625c3962072302f48860331be5&#34;&gt;4. Windows 下载ComEmuPack&lt;/h3&gt;

&lt;p&gt;ComEmuPack是Windows Cmd的替代工具，主要为了解决中文输入和显示问题，Window上使用，如果MAC上使用终端工具就可以terminal或者iterm都可以&lt;/p&gt;

&lt;h2 id=&#34;运行客户端:9c8e3f625c3962072302f48860331be5&#34;&gt;运行客户端&lt;/h2&gt;

&lt;p&gt;复制svnrbclient.py 到你本地SVN的目录下面，这个目录需要和Review Board上面的配置相对应，具体如下例说明：
1.review board配置某个repository是&lt;a href=&#34;https://scm.******.com:8443/svn/Test/automation&#34;&gt;https://scm.******.com:8443/svn/Test/automation&lt;/a&gt;
2.repository的名字是：******-automation,假设你使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;svn checkout https://scm.******.com:8443/svn/******-automation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;检出代码到***&lt;strong&gt;&lt;em&gt;-automation目录，那么你需要将svnrbclient.py复制到你本地的&lt;/em&gt;&lt;/strong&gt;***-automation下面.&lt;/p&gt;

&lt;p&gt;打开命令行工具，运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;python svnrbclient.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以，第一次使用会让你配置你的review board设置，如果嫌麻烦，可以创建如下内容的文件
到.reviewboardrc，不过复制之前需要修改，具体修改参考一下注释.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 不需要修改
REVIEWBOARD_URL = &amp;quot;192.168.3.180&amp;quot;
// 一般修改至你动作的目录名
REPOSITORY = &amp;quot;******-automation&amp;quot;
// 工号
USERNAME=110863
//review board密码，和LDAP密码一样
PASSWORD=&amp;quot;*******&amp;quot;
// 默认代码审查人的工号，可以是****，****格式，,间隔表示多人
TARGET_PEOPLE=****
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用客户端:9c8e3f625c3962072302f48860331be5&#34;&gt;使用客户端&lt;/h2&gt;

&lt;p&gt;在运行客户端之后，可以看到如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;        ****** Review Board Client, ? for help, and the total command lists:
        1. setup:setup review board setting
        2. pre:precommit your changes to review board
        3. upre:update your precommit
        4. ss:svn status,find svn status for the working copies
        5. sa:svn add,add files to local svn
        6. sd:svn delete,delete svn file
        7. ci:svn commit,commit the changes by review request id
        8. sre: revert changes
        9. sdiff: generate differ file
        10.sci: commit the selected files directly
        11.exit: exit the client
       (****** RB Client)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是这个客户端的所有功能，重点是如下几个功能：
1. pre: 创建review request
2. upre： 更新review request
3. ci: review通过之后，提交代码到SVN中央仓库，这个是根据review request id来作的提交
  也就是你提交review request修改了什么文件，使用ci命令就帮你提交此review request修改过的文件
一般执行方法是：在(****** RB Client)后面输入你需要的命令如：pre,然后按照提示一步一步操作就可以了.以下是输入的日志：&lt;/p&gt;

&lt;p&gt;以下是使用pre commit的一个完全的shell场景:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;输入命令pre&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;****** RB Client)pre
// 得到输出，需要选择此次修改的文件：
pre-commit the changes
svn status:
Changed Files Status:
ID |FILE SVN Status|File Name/File Path
0 | ? | .git
1 | ? | .idea
2 | ? | .ignorerc
3 | A | .reviewboardrc
4 | ? | automation-common/automation-common.iml
5 | M | automation-common/src/main/java/com/******/automation/ITestProcessor.java
6 | ? | automation-common/target
7 | A | automation-demo/automation-demo.iml
8 | ? | automation-demo/target
9 | A | differ_temp
10 | A | differ_temp/105
11 | A | differ_temp/105/diff_105_latest.txt
12 | A | differ_temp/105/differ_1432611692.92.txt
13 | A | differ_temp/105/differ_1432612400.93.txt
14 | A | differ_temp/105/notes.txt
15 | A | differ_temp/113
16 | A | differ_temp/113/diff_113_latest.txt
17 | A | differ_temp/113/differ_1432620381.6.txt
18 | A | differ_temp/113/differ_1432620573.37.txt
19 | A | differ_temp/113/notes.txt
20 | A | differ_temp/114
21 | A | differ_temp/114/diff_114_latest.txt
22 | A | differ_temp/114/differ_1432621517.49.txt
23 | A | differ_temp/114/differ_1432621894.64.txt
24 | ? | differ_temp/114/differ_1432622051.84.txt
25 | A | differ_temp/114/notes.txt
26 | ? | differ_temp/115
27 | ? | differ_temp/116
28 | ? | differ_temp/125
29 | ? | differ_temp/132
30 | ? | ******-automation.iml
31 | A | rbtools_requests.py
32 | M | svnrbtclient.py
33 | A | +
34 |  | &amp;gt;
35 | Summary | of
36 |  | Tree
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;输入文件的ID， 可以是5,32，或者是5-32，34-90 表示5-32,34-90的文件&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;Please select the files IDs which your want to commit,eg. 0,1,2,3, or Enter for All Files
&amp;lt;5,32


automation-common/src/main/java/com/******/automation/ITestProcessor.java svnrbtclient.py is ready to post to review board......
Please input your reviewer ID,Entry for default Reviewer&amp;gt;
reviewer ID:
Please input summary for your changes,it is nice to provide your Bug No:&amp;gt;修改svnrbclient
&amp;lt;Response [201]&amp;gt;
None
update draft timeout but it doesn&#39;t matter
draft request review id :133

//到这里review request 提交完毕
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;审核通过之后，输入ci命令，提交review request&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;(****** RB Client)ci

last 5 review requests status:
Request Review Id |Summary  | Status | Changed File List
133 | 修改svnrbclient
 | pending | automation-common/src/main/java/com/******/automation/ITestProcessor.java svnrbtclient.py

132 | 测试很多文件
 | pending | README.md automation-common/src/main/java/com/******/automation/Environment.java automation-common/src/main/java/com/******/automation/ITestProcessor.java automation-common/src/main/java/com/******/automation/drivers/DriverFactory.java automation-common/src/main/java/com/******/automation/helpers/webdriver/WebDriverHelper.java automation-common/src/main/java/com/******/automation/listener/testng/SimpleWebDriverScreenShotTestListener.java automation-common/src/main/java/com/******/automation/testscaffold/BaseWebCurrencyTest.java automation-common/src/main/java/com/******/automation/testscaffold/BaseWebTest.java automation-common/src/main/java/com/******/automation/testscaffold/webtest/WebTestContext.java automation-common/src/main/java/com/******/automation/testscaffold/webtest/webUI/elementloader/locator/CustomerElementLocatorFactory.java automation-common/src/main/java/com/******/automation/testscaffold/webtest/webUI/htmlelements/HtmlElement.java automation-common/src/test/java/com/******/automation/drivers/DriverFactoryTest2.java automation-common/src/test/java/com/******/automation/drivers/DriverFactoryTest_Concurrency.java automation-common/src/test/java/com/******/automation/drivers/testng-test1.xml automation-common/src/test/java/com/******/automation/helpers/webdriver/WebDriverHelperTest.java

115 | 更新readme
 | pending | ******rbclient_en.py README.md

116 | 测试测试
 | pending | ******rbclient.py

125 | 修改中文注释
 | pending | automation-common/src/main/java/com/******/automation/Environment.java automation-common/src/main/java/com/******/automation/ITestProcessor.java

//输入你要需要提交的 review request id号：  //提交结束
(****** RB Client)

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Python PIP mirror设置</title>
      <link>http://simonpatrick.github.io/posts/python/2014-11-24-python_mirror/</link>
      <pubDate>Mon, 24 Nov 2014 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2014-11-24-python_mirror/</guid>
      <description>&lt;p&gt;使用默认的pip mirror速度实在太慢了，所以使用douban的pypi镜像.如何使用呢？很简单，以下几步：
- 修改~/.pip/pip.conf 文件，将index_url改成douban镜像地址:&lt;code&gt;http://pypi.douban.com/simple&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[global]
index-url=http://pypi.douban.com/simple
timeout = 30
require-virtualenv = false
download-cache = /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然记得把require-virtualenv 值改为false&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;关闭终端，重新使用pip命令就可以使用douban镜像了，速度超快&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Python virtualenv in Mac</title>
      <link>http://simonpatrick.github.io/posts/python/2014-11-24-virtual_env/</link>
      <pubDate>Mon, 24 Nov 2014 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2014-11-24-virtual_env/</guid>
      <description>

&lt;p&gt;virtualenv是一个创建python虚拟环境的工具,主要的解决的问题是,让在一个干净的Python环境中开发,不需要被不同的python
安装包烦恼,python3中实际已经内置了venv的,可以不使用virtualenv,以下是简要说明以下安装使用方法:&lt;/p&gt;

&lt;p&gt;ps: 关于Python3和Python2很有可能在同一台机器上都有安装,所以注意python命令对应的是那个版本.have fun :)&lt;/p&gt;

&lt;h2 id=&#34;python3-in-mac:0cad8d60d9b2482972ae9779a38bd75e&#34;&gt;Python3 in Mac&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;python3 -m venv todo_mvc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Done &amp;hellip;&amp;hellip;&amp;hellip;.&lt;/p&gt;

&lt;h2 id=&#34;python2-in-mac:0cad8d60d9b2482972ae9779a38bd75e&#34;&gt;Python2 in Mac&lt;/h2&gt;

&lt;h3 id=&#34;install-virtualenv-in-mac:0cad8d60d9b2482972ae9779a38bd75e&#34;&gt;Install virtualenv in Mac&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	sudo pip install virtualenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此前确认pip已经安装了&lt;/p&gt;

&lt;h3 id=&#34;install-virtualenvwapper-in-mac:0cad8d60d9b2482972ae9779a38bd75e&#34;&gt;Install virtualenvwapper in Mac&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; sudo pip install virtualenvwapper
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;创建python开发环境:0cad8d60d9b2482972ae9779a38bd75e&#34;&gt;创建python开发环境&lt;/h3&gt;

&lt;h4 id=&#34;直接使用virtualevn:0cad8d60d9b2482972ae9779a38bd75e&#34;&gt;直接使用virtualevn&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;创建目录&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	mkdir python_test
	virtualenv python_test
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;使用创建好的目录作为开发环境&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	source /bin/activate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动开发环境之后，可以使用pip安装需要的python依赖库，如selenium&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install selenium
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果安装好了virtualenvwapper的话，可以使用如下命令使用开发环境：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkvirtualenv python_test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;退出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;deactivate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切换：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;	workon python-test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;rm virtualenv python-test
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Simple Sorting in Python And Ruby</title>
      <link>http://simonpatrick.github.io/posts/2014-08-24-simple_sorting_in_python_ruby/</link>
      <pubDate>Sun, 24 Aug 2014 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/2014-08-24-simple_sorting_in_python_ruby/</guid>
      <description>

&lt;p&gt;不同语言的排序&lt;/p&gt;

&lt;h2 id=&#34;python:d479efe8838a50e9cf62b923783883d0&#34;&gt;Python&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=[5,3,2,2,90,12]
sorted(a)
sorted(a,reverse=True)
a.sort()
a.sort(reserve=True)

f = [&#39;abcd&#39;,&#39;CCCC&#39;]
sorted(c,key=len)
sorted(c,key=str.lower)
sorted(c,key=lastchar)

f = [{&#39;name&#39;:&#39;abc&#39;,&#39;age&#39;:20},{&#39;name&#39;:&#39;def&#39;,&#39;age&#39;:30}]
def age(s):
  return s[&#39;age&#39;]

ff=sorted(f,key=age)
f2=sorted(f,key=lambda x:x[&#39;age&#39;])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ruby:d479efe8838a50e9cf62b923783883d0&#34;&gt;Ruby&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;a = [ &amp;quot;d&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;b&amp;quot; ]
a.sort                    #=&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;]
a.sort { |x,y| y &amp;lt;=&amp;gt; x }  #=&amp;gt; [&amp;quot;e&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;]
a.sort { |x,y| x &amp;lt;=&amp;gt; Y }  #=&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;]

a = [ &amp;quot;d&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;e&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;b&amp;quot; ]
a.sort!                    #=&amp;gt; [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;]
a.sort! { |x,y| y &amp;lt;=&amp;gt; x }  #=&amp;gt; [&amp;quot;e&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Python 基础-字符串处理</title>
      <link>http://simonpatrick.github.io/posts/python/2013-11-24-python_string/</link>
      <pubDate>Sun, 24 Nov 2013 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2013-11-24-python_string/</guid>
      <description>

&lt;p&gt;学习一门语言，就当多一门手艺。虽然是个测试，被人唾弃，但是相信自己比什么都重要。
卷起袖子，dirty your hand。以下是学习&lt;a href=&#34;https://github.com/qiwsir/StarterLearningPython的笔记&#34;&gt;https://github.com/qiwsir/StarterLearningPython的笔记&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;python-运行:85ad16b9ebf8950ae832e24c7ac70abc&#34;&gt;python 运行&lt;/h2&gt;

&lt;p&gt;以下是python运行命令，同时带了两个不同的参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;	python &amp;lt;filename&amp;gt;.py # pyc 文件生成
	python &amp;lt;filename&amp;gt;.py # pyo 文件生成，优化了的python字节码
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数字-变量-计算:85ad16b9ebf8950ae832e24c7ac70abc&#34;&gt;数字，变量，计算&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;python里面的数字主要又以下几种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;整数， 如2&lt;/li&gt;
&lt;li&gt;浮点数，如2.22&lt;/li&gt;
&lt;li&gt;长整数，如2.222222222222L&lt;/li&gt;
&lt;li&gt;其他如：十进制，还有二进制、八进制、十六进制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;python 变量&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对象有类型，变量无类型， 如何理解 x=5, x 没有赋值时没有类型，当=5时就是int了，如果x=&amp;lsquo;str&amp;rsquo;时，就是String了&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;四则运算
运算符号：
#- +,-,*,/#&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看一下例子就可以了解基本的运算和类型了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=4+2
b=4.0+2
#自动处理整数溢出
x= 123456789870987654321122343445567678890098876*1233455667789990099876543332387665443345566999999999999

print a,b,x
print(type(a))
print(type(b))
print(type(x))


print a/b
print a/2
#不管是被除数还是除数，只要有一个数是浮点数，结果就是浮点数
print a/2.0
print x/0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上预算的结果,出错信息也显而易见&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
6 6.0 152278477193527562870044352587576277277562451818822315203216690188373592848234522837124321109901124
&amp;lt;type &#39;int&#39;&amp;gt;
&amp;lt;type &#39;float&#39;&amp;gt;
&amp;lt;type &#39;long&#39;&amp;gt;

1.0
3
3.0

ZeroDivisionError: long division or modulo by zero

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于数值计算来说,以下内容供参考
&amp;gt;
对于需要非常精确的情况，可以使用 decimal 模块，它实现的十进制运算适合会计方面的应用和高精度要求的应用。另外 fractions 模块支持另外一种形式的运算，它实现的运算基于有理数（因此像1/3这样的数字可以精确地表示）。最高要求则可是使用由 SciPy提供的 Numerical Python 包和其它用于数学和统计学的包。列出这些东西，仅仅是让看官能明白，解决问题的方式很多，后面会用这些中的某些方式解决上述问题。
&lt;a href=&#34;https://docs.python.org/2/tutorial/floatingpoint.html#tut-fp-issues&#34;&gt;浮点数算法：争议和限制&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用计算模块-division:85ad16b9ebf8950ae832e24c7ac70abc&#34;&gt;使用计算模块 &lt;code&gt;division&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;使用python的模块来作除法：&lt;code&gt;from __future__ import division&lt;/code&gt; 所有的除法就都是浮点数了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;	from __future__ import division
	print 5/2  # 2.5 如果不用division，则为2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整除方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print divmod(5,2) # 返回元组（2，1）
print divmod(10,3)[0],divmod(10,3)[1],divmod(10,3)
# 结果是：
3 1 (3, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;四舍五入-round:85ad16b9ebf8950ae832e24c7ac70abc&#34;&gt;四舍五入 &lt;code&gt;round&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;四舍五入取位数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print round(1.2345567, 2)
print round(1.23456677, 3)
print round(10.0 / 3, 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.23
1.235
3.3333
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下结果不要惊慌,这是正常的！！！！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;round(1.2345,3)
1.234               #应该是：1.235
round(2.235,2)
2.23                #应该是：2.24

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;math-模块小试:85ad16b9ebf8950ae832e24c7ac70abc&#34;&gt;Math 模块小试&lt;/h2&gt;

&lt;p&gt;以下代码小试以下Math模块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print math.pi
functions = dir(math)
print pow(4, 2)
for x in functions:
    print x
    print help(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;优先级:85ad16b9ebf8950ae832e24c7ac70abc&#34;&gt;优先级&lt;/h2&gt;

&lt;p&gt;以下是优先级从低到高的顺序：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;lambda&lt;/td&gt;
&lt;td&gt;Lambda表达式&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;or&lt;/td&gt;
&lt;td&gt;布尔“或”&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;布尔“与”&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;not x&lt;/td&gt;
&lt;td&gt;布尔“非”&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;in，not in&lt;/td&gt;
&lt;td&gt;成员测试&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;is，is not&lt;/td&gt;
&lt;td&gt;同一性测试&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;，&amp;lt;=，&amp;gt;，&amp;gt;=，!=，==&lt;/td&gt;
&lt;td&gt;比较&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;|按位或&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;按位异或&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;按位与&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;lt;，&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;移位&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;+，-&lt;/td&gt;
&lt;td&gt;加法与减法&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;*，/，%&lt;/td&gt;
&lt;td&gt;乘法、除法与取余&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;+x，-x&lt;/td&gt;
&lt;td&gt;正负号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;~x&lt;/td&gt;
&lt;td&gt;按位翻转&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;**&lt;/td&gt;
&lt;td&gt;指数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;x.attribute&lt;/td&gt;
&lt;td&gt;属性参考&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;x[index]&lt;/td&gt;
&lt;td&gt;下标&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;x[index:index]&lt;/td&gt;
&lt;td&gt;寻址段&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;f(arguments&amp;hellip;)&lt;/td&gt;
&lt;td&gt;函数调用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(experession,&amp;hellip;)&lt;/td&gt;
&lt;td&gt;绑定或元组显示&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[expression,&amp;hellip;]&lt;/td&gt;
&lt;td&gt;列表显示&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;{key:datum,&amp;hellip;}&lt;/td&gt;
&lt;td&gt;字典显示&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lsquo;expression,&amp;hellip;&amp;rsquo;&lt;/td&gt;
&lt;td&gt;字符串转换&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Python 基础-语法</title>
      <link>http://simonpatrick.github.io/posts/python/2013-11-24-python_basic/</link>
      <pubDate>Sun, 24 Nov 2013 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2013-11-24-python_basic/</guid>
      <description>

&lt;p&gt;学习一门语言，就当多一门手艺。虽然是个测试，被人唾弃，但是相信自己比什么都重要。
卷起袖子，dirty your hand。以下是学习&lt;a href=&#34;https://github.com/qiwsir/StarterLearningPython的笔记&#34;&gt;https://github.com/qiwsir/StarterLearningPython的笔记&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;python-运行:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;python 运行&lt;/h2&gt;

&lt;p&gt;以下是python运行命令，同时带了两个不同的参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;	python &amp;lt;filename&amp;gt;.py # pyc 文件生成
	python &amp;lt;filename&amp;gt;.py # pyo 文件生成，优化了的python字节码
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;数字-变量-计算:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;数字，变量，计算&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;python里面的数字主要又以下几种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;整数， 如2&lt;/li&gt;
&lt;li&gt;浮点数，如2.22&lt;/li&gt;
&lt;li&gt;长整数，如2.222222222222L&lt;/li&gt;
&lt;li&gt;其他如：十进制，还有二进制、八进制、十六进制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;python 变量&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对象有类型，变量无类型， 如何理解 x=5, x 没有赋值时没有类型，当=5时就是int了，如果x=&amp;lsquo;str&amp;rsquo;时，就是String了&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;四则运算
运算符号：
&lt;code&gt;
#- +,-,*,/#
&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看一下例子就可以了解基本的运算和类型了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=4+2
b=4.0+2
#自动处理整数溢出
x= 123456789870987654321122343445567678890098876*1233455667789990099876543332387665443345566999999999999

print a,b,x
print(type(a))
print(type(b))
print(type(x))


print a/b
print a/2
#不管是被除数还是除数，只要有一个数是浮点数，结果就是浮点数
print a/2.0
print x/0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上预算的结果,出错信息也显而易见&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
6 6.0 152278477193527562870044352587576277277562451818822315203216690188373592848234522837124321109901124
&amp;lt;type &#39;int&#39;&amp;gt;
&amp;lt;type &#39;float&#39;&amp;gt;
&amp;lt;type &#39;long&#39;&amp;gt;

1.0
3
3.0

ZeroDivisionError: long division or modulo by zero

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于数值计算来说,以下内容供参考
&amp;gt;
对于需要非常精确的情况，可以使用 decimal 模块，它实现的十进制运算适合会计方面的应用和高精度要求的应用。另外 fractions 模块支持另外一种形式的运算，它实现的运算基于有理数（因此像1/3这样的数字可以精确地表示）。最高要求则可是使用由 SciPy提供的 Numerical Python 包和其它用于数学和统计学的包。列出这些东西，仅仅是让看官能明白，解决问题的方式很多，后面会用这些中的某些方式解决上述问题。
&lt;a href=&#34;https://docs.python.org/2/tutorial/floatingpoint.html#tut-fp-issues&#34;&gt;浮点数算法：争议和限制&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用计算模块-division:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;使用计算模块 &lt;code&gt;division&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;使用python的模块来作除法：&lt;code&gt;from __future__ import division&lt;/code&gt; 所有的除法就都是浮点数了:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;	from __future__ import division
	print 5/2  # 2.5 如果不用division，则为2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整除方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print divmod(5,2) # 返回元组（2，1）
print divmod(10,3)[0],divmod(10,3)[1],divmod(10,3)
# 结果是：
3 1 (3, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;四舍五入-round:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;四舍五入 &lt;code&gt;round&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;四舍五入取位数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print round(1.2345567, 2)
print round(1.23456677, 3)
print round(10.0 / 3, 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.23
1.235
3.3333
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下结果不要惊慌,这是正常的！！！！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;round(1.2345,3)
1.234               #应该是：1.235
round(2.235,2)
2.23                #应该是：2.24

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;math-模块小试:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;Math 模块小试&lt;/h2&gt;

&lt;p&gt;以下代码小试以下Math模块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print math.pi
functions = dir(math)
print pow(4, 2)
for x in functions:
    print x
    print help(x)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;优先级:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;优先级&lt;/h2&gt;

&lt;p&gt;以下是优先级从低到高的顺序：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;lambda&lt;/td&gt;
&lt;td&gt;Lambda表达式&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;or&lt;/td&gt;
&lt;td&gt;布尔“或”&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;布尔“与”&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;not x&lt;/td&gt;
&lt;td&gt;布尔“非”&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;in，not in&lt;/td&gt;
&lt;td&gt;成员测试&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;is，is not&lt;/td&gt;
&lt;td&gt;同一性测试&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;，&amp;lt;=，&amp;gt;，&amp;gt;=，!=，==&lt;/td&gt;
&lt;td&gt;比较&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;|按位或&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;按位异或&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;按位与&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;lt;，&amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;移位&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;+，-&lt;/td&gt;
&lt;td&gt;加法与减法&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;*，/，%&lt;/td&gt;
&lt;td&gt;乘法、除法与取余&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;+x，-x&lt;/td&gt;
&lt;td&gt;正负号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;~x&lt;/td&gt;
&lt;td&gt;按位翻转&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;**&lt;/td&gt;
&lt;td&gt;指数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;x.attribute&lt;/td&gt;
&lt;td&gt;属性参考&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;x[index]&lt;/td&gt;
&lt;td&gt;下标&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;x[index:index]&lt;/td&gt;
&lt;td&gt;寻址段&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;f(arguments&amp;hellip;)&lt;/td&gt;
&lt;td&gt;函数调用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;(experession,&amp;hellip;)&lt;/td&gt;
&lt;td&gt;绑定或元组显示&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[expression,&amp;hellip;]&lt;/td&gt;
&lt;td&gt;列表显示&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;{key:datum,&amp;hellip;}&lt;/td&gt;
&lt;td&gt;字典显示&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;lsquo;expression,&amp;hellip;&amp;rsquo;&lt;/td&gt;
&lt;td&gt;字符串转换&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;1-python基础常识:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;1.Python基础常识&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;安装python（windows基本就是下载后安装，linux和mac自带&lt;/li&gt;
&lt;li&gt;添加python到windows 的path中&lt;/li&gt;
&lt;li&gt;执行python文件： &lt;code&gt;python &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;python 文件 encoding&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    &#39;#_*_coding:utf-8_*_&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;注释&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;quot;&amp;quot;&amp;quot; docs &amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-python-注释和-号:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;2.Python 注释和#号&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;# A comment&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-数字和数字计算:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;3.数字和数字计算&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;- +，-，/,*,%,&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-变量-variable-和命名:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;4. 变量&lt;variable&gt;和命名&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;car = 100&lt;/li&gt;
&lt;li&gt;space_in_a_car = 4.0&lt;/li&gt;
&lt;li&gt;和java的常用规范还是有点不同，python不用驼峰&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;5-打印更多的变量:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;5. 打印更多的变量&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;格式化打印&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print &amp;quot;this is for %s&amp;quot;, %test
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-字符串和文本:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;6.字符串和文本&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;可以带格式参数赋值&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; x= &amp;quot;%s,%s&amp;quot; % (s1,s2)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;%r-用来debug raw data会打印,%s&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;7-转义字符:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;7. 转义字符&lt;/h3&gt;

&lt;h3 id=&#34;8-raw-input-xxxxx:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;8. raw_input(&amp;ldquo;XXXXX&amp;rdquo;)&lt;/h3&gt;

&lt;h3 id=&#34;9-参数-解包-变量:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;9. 参数，解包，变量&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; from sys import argv
    script,first, second, third = argv
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;10-io:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;10. IO&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;close–关闭文件。跟你编辑器的文件-&amp;gt;保存..一个意思&lt;/li&gt;
&lt;li&gt;read – 读取文件内容。你可以把结果赋给一个变量&lt;/li&gt;
&lt;li&gt;readline–读取文本文件中的一行&lt;/li&gt;
&lt;li&gt;truncate–清空文件,请小心使用该命令&lt;/li&gt;
&lt;li&gt;write(stuff) – 将 stuff 写入文件&lt;/li&gt;
&lt;li&gt;open(&amp;ldquo;&amp;rdquo;,a/w/r), read, write, append&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;11-function-and-variants:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;11. Function and Variants&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def functionName() :
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;12-return-of-function:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;12. return of Function&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def function1():
    return 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###13.逻辑关系
###14.布尔表达式
###15.if, if-else,if-elif-else
###16.循环，列表
###17. 列表&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;定义 ：[]&lt;/li&gt;
&lt;li&gt;append： element.append()&lt;/li&gt;
&lt;li&gt;访问index x[0]&amp;hellip;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###18. 关键字&lt;/p&gt;

&lt;p&gt;• and
• del
• from • not
• while • as
• elif
• global
• or
• with
• assert
• else
• if
• pass
• yield
• break
• except
• import
• print
• class
• exec
• in
• raise
• continue • finally • is
• return
• def
• for
• lambda/try&lt;/p&gt;

&lt;p&gt;###19. 数据类型&lt;/p&gt;

&lt;p&gt;• True
• False
• None
• strings • numbers • floats • lists&lt;/p&gt;

&lt;p&gt;###20. list and dictionary&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;list : []&lt;/li&gt;
&lt;li&gt;dictionary :{&amp;ldquo;key&amp;rdquo; :&amp;ldquo;value&amp;rdquo;}&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###21. module,class,object&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;module: 不是类，里面可以定义函数，变量，大体可以看做一个静态类或者一个单例类&lt;/li&gt;
&lt;li&gt;class：和JAVA里面的类相似&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    __author__ = &#39;simon&#39;
    # _*_ coding:utf-8 _*_

    # 定义类
    class MyStuff(object):
        def __init__(self):  # 初始化类，构造器
            self.target = &amp;quot;Andriod&amp;quot;
    # self 就是 this
        def apple(self):
            print self.target
            print &amp;quot;test apple&amp;quot;

    # 实例化
    myStuff = MyStuff()
    myStuff.apple()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###22. is-a/has-a
###23. 继承(Inheritance)VS合成(composition)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;隐身继承&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#隐身继承
    class Parent(object):
        def implicit(self):
         print(&amp;quot;implicit class!&amp;quot;)

    class Child(Parent):
        pass
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;显示继承&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    ##显示继承
    class Test(object):
        def override(self):
            print &amp;quot;parent override&amp;quot;

    class TestChild(Test):
        def override(self):
            print &amp;quot;child override&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;super（）&lt;/li&gt;
&lt;li&gt;多重继承（multiple inheritance）&lt;/li&gt;
&lt;li&gt;composition组合&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # _*_ coding=utf-8 _*_
    __author__ = &#39;patrick&#39;

    class Other(object):
        def overrider(self):
            print &amp;quot;override&amp;quot;

        def altered(self):
            print &amp;quot;other alter!&amp;quot;

    class Child(object):
        def __init__(self):
            self.other =Other()

        def override(self):
            self.other.overrider()

        def altered(self):
            self.other.altered()

    child = Child()
    child.altered()
    child.override()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;###24.Python风格&lt;/p&gt;

&lt;p&gt;1.类名:camel case/method 名字： underscore format
2.class name（object）
3.注释说为什么这样子做，而不是怎么做&lt;/p&gt;

&lt;p&gt;以下是学习python guide时候的一些笔记，同时应该是满足所有的编程语言的。&lt;/p&gt;

&lt;h2 id=&#34;1-writing-great-code:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;1. Writing Great Code&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;structuring your project&lt;/li&gt;
&lt;li&gt;code style&lt;/li&gt;
&lt;li&gt;reading great codes&lt;/li&gt;
&lt;li&gt;documentation&lt;/li&gt;
&lt;li&gt;testing your codes&lt;/li&gt;
&lt;li&gt;logging&lt;/li&gt;
&lt;li&gt;common gotchas&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-1-structuring-your-project:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;1.1 structuring your project&lt;/h3&gt;

&lt;p&gt;不要小看了这个项目结构，好的结构可以让项目一目了然。好的项目结构可能就回答了以下几个问题：
- which function should go into which modules
- how does the data flow through the project
- which functions and features can be grouped together and isolated&lt;/p&gt;

&lt;p&gt;以下是一些不好的设计：
- 不同的内容放在一起而相互影响
- 隐含的依赖，hidden coupling
- 全部变量和状态的滥用
- spaghetti code and ravioli code&lt;/p&gt;

&lt;p&gt;对于python来说，处理这些组织代码的事情可以使用modules，package(&lt;strong&gt;init&lt;/strong&gt;.py),还有一些重用的方法如：
- decorators&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def foo():
  # do something
def decorator(func):
  # do something
  return func

# manually decorator
foo = decorator(foo)

@decorator
def bar():
  # Do something

# bar is decorated
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;dynamic typing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;变量可以不是固定类型，Variables are not a segment of the computer’s memory where some value is written, they are ‘tags’ or ‘names’ pointing to objects.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mutable and immutable types&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;mutable: list, dict
immutable: int&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;my_list = [1,2,3,4]
my_list[0]=4
print my_list  # the same list

x = 6
x=x+1 # the next x is another object
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;foo = &#39;foo&#39;
bar = &#39;bar&#39;
foobar = &#39;%s%s&#39; % (foo, bar) # It is OK
foobar = &#39;{0}{1}&#39;.format(foo, bar) # It is better
foobar = &#39;{foo}{bar}&#39;.format(foo=foo, bar=bar) # It is best

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-2-code-style:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;1.2 code style&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Explicit code&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Bad
￼def make_complex(*args):
  x, y = args
  return dict(**locals())

# good
def make_complex(x,y):
  return {&#39;x&#39;:x,‘y’：y}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;function arguments&lt;/li&gt;
&lt;li&gt;positonal arguments&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;send(message, recipient)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;keywords arguments&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;send(message, to, cc=None, bcc=None)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;arbitrary argument list&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;send(message, *args)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;arbitrary keyword argument dictionary&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;send(message, **args)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Avoid the magical wand/all responsible users
The main convention for private properties and implementation details is to prefix all “internals” with an underscore.&lt;/li&gt;
&lt;li&gt;return values
raising exception or return None/False&lt;/li&gt;
&lt;li&gt;Idioms&lt;/li&gt;
&lt;li&gt;unpacking&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for index,item in enumerate(some_list):
  # do something

a,b=b,a
a,(b,c)=1,(2,3)

# python3
a,*rest=[1,2,3]
b,*middle,c=[1,2,3,4,5]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;create an ignored Variables&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;￼filename = &#39;foobar.txt&#39;
basename, __, ext = filename.rpar
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;PEP8&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;pep8 optparse.py
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;convertions&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# don&#39;t use has_key in dictionary
d ={&#39;hello&#39;:&#39;world&#39;}
print d.get(&#39;hello&#39;,default_value)
if &#39;hello&#39; in d:
  print d[&#39;hello&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;short ways to manipulate lists&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# bad
a = [3, 4, 5]
b = []
for i in a:
  if i &amp;gt; 4: b.append(i)

# good
a = [3, 4, 5]
b = [i for i in a if i &amp;gt; 4]
# Or:
b = filter(lambda x: x &amp;gt; 4, a)

a = [3, 4, 5]
a = [i + 3 for i in a]
# Or:
a = map(lambda i: i + 3, a)

a = [3, 4, 5]
for i, item in enumerate(a):
  print i, item
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;read from a file&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;￼with open(&#39;file.txt&#39;) as f:
  for line in f:
      print line
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;line continuations&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# bad
my_very_big_string = &amp;quot;&amp;quot;&amp;quot;For a long time I used to go to bed early. Sometimes, \
    when I had put out my candle, my eyes would close so quickly that I had not even \
    time to say “I’m going to sleep.”&amp;quot;&amp;quot;&amp;quot;
from some.deep.module.inside.a.module import a_nice_function, another_nice_function,  yet_another_nice_function

# good
my_very_big_string = (
&amp;quot;For a long time I used to go to bed early. Sometimes, &amp;quot;
&amp;quot;when I had put out my candle, my eyes would close so quickly &amp;quot; &amp;quot;that I had not even time to say “I’m going to sleep.”&amp;quot;
)

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-3-read-great-codes:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;1.3 read great codes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Howdoi Howdoi is a code search tool, written in Python.&lt;/li&gt;
&lt;li&gt;Flask Flask is a microframework for Python based on Werkzeug and Jinja2. It’s intended for getting started very
quickly and was developed with best intentions in mind.&lt;/li&gt;
&lt;li&gt;Werkzeug Werkzeug started as simple collection of various utilities for WSGI applications and has become one of the most advanced WSGI utility modules. It includes a powerful debugger, full-featured request and response objects, HTTP utilities to handle entity tags, cache control headers, HTTP dates, cookie handling, file uploads, a powerful URL routing system and a bunch of community-contributed addon modules.&lt;/li&gt;
&lt;li&gt;Requests Requests is an Apache2 Licensed HTTP library, written in Python, for human beings.&lt;/li&gt;
&lt;li&gt;Tablib Tablib is a format-agnostic tabular dataset library, written in Python.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-4-ducomentation:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;1.4 ducomentation&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;readme&lt;/li&gt;
&lt;li&gt;project documentation&lt;/li&gt;
&lt;li&gt;api reference&lt;/li&gt;
&lt;li&gt;tutorial&lt;/li&gt;
&lt;li&gt;reStructuredText documentation&lt;/li&gt;
&lt;li&gt;code documentation advice&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;￼def square_and_rooter(x):
&amp;quot;&amp;quot;&amp;quot;Returns the square root of self times self.&amp;quot;&amp;quot;&amp;quot;
  # do something
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do not use triple-quote strings to comment code. This is not a good practice.
PEP 257&lt;/p&gt;

&lt;h2 id=&#34;1-5-testing-your-codes:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;1.5 Testing your codes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;unittest/unittest2&lt;/li&gt;
&lt;li&gt;doctest&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The doctest module searches for pieces of text that look like interactive Python sessions in docstrings, and then executes those sessions to verify that they work exactly as shown.
Doctests have a different use case than proper unit tests: they are usually less detailed and don’t catch special cases or obscure regression bugs. They are useful as an expressive documentation of the main use cases of a module and its components. However, doctests should run automatically each time the full test suite runs.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pytest&lt;/li&gt;
&lt;li&gt;nose&lt;/li&gt;
&lt;li&gt;tox&lt;/li&gt;
&lt;li&gt;mock&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-6-logging:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;1.6 logging&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;diagnositic logging&lt;/li&gt;
&lt;li&gt;audit logging&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-7-common-gotchas:464106ad89d0a0b7f7d2b73f4a61ff64&#34;&gt;1.7 common gotchas&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;mutable  default arguments
default argumant is mutable, python的方法每次被访问时不是重新建立，所以一定要小心，除非你是exploit(user as intended)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def append_to(element,to=[]):
  to.append(element)
  return to

# what you expected to happen
my_list=append_to(12)
print my_list
my_list=append_to(42)
print my_list

# your expected result:
[12]
[42]

# but actual result:
[12]
[12,42]

# so

def append_to(element,to=None):
  to.append(element)
  return to
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;late binding closure&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def create_mulipliers():
  return [lambda x : i * x for i in range(5)]

for n in create_mulipliers():
      print n(2)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python’s closures are late binding. This means that the values of variables used in closures are looked up at the time
the inner function is called.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python 常用包</title>
      <link>http://simonpatrick.github.io/posts/python/2013-11-24-python_libs/</link>
      <pubDate>Sun, 24 Nov 2013 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2013-11-24-python_libs/</guid>
      <description>

&lt;p&gt;python常用包介绍&lt;/p&gt;

&lt;h1 id=&#34;network-application:38ef1306c7d6fc5efe2d018fcbe98524&#34;&gt;Network Application&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;HTTP&lt;/li&gt;
&lt;li&gt;Requests&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;distrbuted-systems:38ef1306c7d6fc5efe2d018fcbe98524&#34;&gt;Distrbuted systems&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;ZeroMQ&lt;/li&gt;
&lt;li&gt;RabbitMQ&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;web-applications:38ef1306c7d6fc5efe2d018fcbe98524&#34;&gt;Web applications&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;WSGI&lt;/li&gt;
&lt;li&gt;Flask&lt;/li&gt;
&lt;li&gt;URL routing&lt;/li&gt;
&lt;li&gt;Template Engine&lt;/li&gt;
&lt;li&gt;development Web Server&lt;/li&gt;
&lt;li&gt;Django&lt;/li&gt;
&lt;li&gt;Werkzeug&lt;/li&gt;
&lt;li&gt;Tornado&lt;/li&gt;
&lt;li&gt;Pyramid&lt;/li&gt;
&lt;li&gt;Nginx&lt;/li&gt;
&lt;li&gt;WSGI Server&lt;/li&gt;
&lt;li&gt;Gunicorn&lt;/li&gt;
&lt;li&gt;uWSGI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The majority of self-hosted Python applications today are hosted with a WSGI server such as Gunicorn, either directly or behind a lightweight web server such as nginx.
The WSGI servers serve the Python applications while the web server handles tasks better suited for it such as static file serving, request routing, DDoS protection, and basic authentication.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Jinja2&lt;/li&gt;
&lt;li&gt;Chameleon&lt;/li&gt;
&lt;li&gt;lxml and Requests&lt;/li&gt;
&lt;li&gt;curl&lt;/li&gt;
&lt;li&gt;grep&lt;/li&gt;
&lt;li&gt;httpie&lt;/li&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;clint&lt;/li&gt;
&lt;li&gt;click&lt;/li&gt;
&lt;li&gt;docopt&lt;/li&gt;
&lt;li&gt;plac&lt;/li&gt;
&lt;li&gt;cliff&lt;/li&gt;
&lt;li&gt;camelot&lt;/li&gt;
&lt;li&gt;cocoa&lt;/li&gt;
&lt;li&gt;GTK&lt;/li&gt;
&lt;li&gt;kivy&lt;/li&gt;
&lt;li&gt;pyobjc&lt;/li&gt;
&lt;li&gt;pyside&lt;/li&gt;
&lt;li&gt;pyqt&lt;/li&gt;
&lt;li&gt;pyjamasDesktop&lt;/li&gt;
&lt;li&gt;DB-API&lt;/li&gt;
&lt;li&gt;SQLAlchemy&lt;/li&gt;
&lt;li&gt;Django ORM&lt;/li&gt;
&lt;li&gt;peewee&lt;/li&gt;
&lt;li&gt;ponyORM&lt;/li&gt;
&lt;li&gt;SQLObject&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;networking:38ef1306c7d6fc5efe2d018fcbe98524&#34;&gt;Networking&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;twisted&lt;/li&gt;
&lt;li&gt;pyzmq&lt;/li&gt;
&lt;li&gt;gevent&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;system-administration:38ef1306c7d6fc5efe2d018fcbe98524&#34;&gt;System Administration&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Fabric&lt;/li&gt;
&lt;li&gt;Salt&lt;/li&gt;
&lt;li&gt;Psutil&lt;/li&gt;
&lt;li&gt;Ansible&lt;/li&gt;
&lt;li&gt;Chef&lt;/li&gt;
&lt;li&gt;Puppet&lt;/li&gt;
&lt;li&gt;BluePrint&lt;/li&gt;
&lt;li&gt;Buildout&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ci:38ef1306c7d6fc5efe2d018fcbe98524&#34;&gt;CI&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Jenkins&lt;/li&gt;
&lt;li&gt;Tox&lt;/li&gt;
&lt;li&gt;Buildout&lt;/li&gt;
&lt;li&gt;Mule&lt;/li&gt;
&lt;li&gt;Travis-CI&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;context-and-tools:38ef1306c7d6fc5efe2d018fcbe98524&#34;&gt;Context And Tools&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;the GIL&lt;/li&gt;
&lt;li&gt;Numba&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>