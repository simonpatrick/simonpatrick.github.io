<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Microservice on Colored Hedwig</title>
    <link>http://simonpatrick.github.io/categories/microservice/</link>
    <description>Recent content in Microservice on Colored Hedwig</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 01 Feb 2016 23:57:29 +0000</lastBuildDate>
    <atom:link href="http://simonpatrick.github.io/categories/microservice/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>01-微服务框架－Springboot/Flask,Hello World</title>
      <link>http://simonpatrick.github.io/posts/microservice/2016-02-01-microservice-try/</link>
      <pubDate>Mon, 01 Feb 2016 23:57:29 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/microservice/2016-02-01-microservice-try/</guid>
      <description>

&lt;p&gt;现在有很多的微服务框架，这里试用一下Java Springboot和Python的Flask.
本文分别试用SpringBoot和Flask完成了一个简单的Hello World服务来展示如何使用Springboot和Flask构建
一个简单的服务. 同时用AB进行了一个简单的压力测试。&lt;/p&gt;

&lt;h2 id=&#34;springboot-hello-world-web-application:f52343a2a46f58140124ef653bf998a9&#34;&gt;SpringBoot Hello World Web Application&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Create a SpringBoot Application entry point&lt;/li&gt;
&lt;li&gt;add Beans into springboot startup life cycle&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  利用command-line runner的这个特性，再配合依赖注入，可以在应用程序启动时后首先引入一些依赖bean，例如data source、rpc服务或者其他模块等等，这些对象的初始化可以放在run方法中。不过，需要注意的是，在run方法中执行初始化动作的时候一旦遇到任何异常，都会使得应用程序停止运行，因此最好利用try/catch语句处理可能遇到的异常。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;create HelloWorld Service&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;all-codes-for-the-simple-hello-world-service:f52343a2a46f58140124ef653bf998a9&#34;&gt;All Codes for the simple &lt;strong&gt;&lt;em&gt;hello world&lt;/em&gt;&lt;/strong&gt; Service&lt;/h2&gt;

&lt;p&gt;以下代码的一些说明：
- Web 应用的执行入口： main方法，里面的SpringApplication.run
- StartupRunner 可以在SpringBoot Application启动过程中一些事情
- RestController注解表示了这个类是个Rest 风格的Controller&lt;/p&gt;

&lt;p&gt;pom.xml 中的唯一依赖，请指定版本或者parent指定为        &lt;code&gt;&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@RestController
public class HelloWorldEndPoint {

    public static void main(String[] args) {
        SpringApplication.run(HelloWorldEndPoint.class,args);
    }

    public static class StartupRunner implements CommandLineRunner{
        protected final Logger logger = LoggerFactory.getLogger(StartupRunner.class);

        @Override
        public void run(String... strings) throws Exception {
            logger.info(&amp;quot;startup command is running ........&amp;quot;);
        }
    }
    //inject into spring start lifecycle
    @Bean
    @Order(value = 1)
    public StartupRunner runner(){
        return new StartupRunner();
    }

    @Bean
    @Order(value = 2)
    public StartupRunner runner2(){
        return new StartupRunner(){

            @Override
            public void run(String... strings) throws Exception {
                System.out.println(&amp;quot;start up 2 command is running......&amp;quot;);
            }
        };
    }

    @RequestMapping(&amp;quot;/&amp;quot;)
    @ResponseBody
    public String home(){
        return &amp;quot;hello world!&amp;quot;;
    }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;启动springboot-应用:f52343a2a46f58140124ef653bf998a9&#34;&gt;启动springboot 应用&lt;/h2&gt;

&lt;p&gt;运行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mvn spring-boot:run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以启动springboot的应用，默认是tomcat的容器，如果又需要修改tomcat的配置，再后面文章中说明。&lt;/p&gt;

&lt;h2 id=&#34;curl测试:f52343a2a46f58140124ef653bf998a9&#34;&gt;curl测试&lt;/h2&gt;

&lt;p&gt;使用curl简单测试一下，可以访问，是不是简单呀&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ curl http://localhost:8080/                                                            
hello world!%
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;helloworld-in-flask:f52343a2a46f58140124ef653bf998a9&#34;&gt;HelloWorld In Flask&lt;/h1&gt;

&lt;p&gt;构建Flask的Micro Service 系列的第一篇，Hello World Service&lt;/p&gt;

&lt;h2 id=&#34;flask-环境设置:f52343a2a46f58140124ef653bf998a9&#34;&gt;Flask 环境设置&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;安装Python3&lt;/li&gt;
&lt;li&gt;创建干净的web 应用的python3 环境,python3 可以不用virtualevn，直接用一下命令就可以了
&lt;code&gt;sh
python3 -m venv &amp;lt;your_application_name&amp;gt;
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;flask-helloworld-service:f52343a2a46f58140124ef653bf998a9&#34;&gt;Flask HelloWorld Service&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from flask import Flask

hello_world=Flask(__name__)

@hello_world.rooter(&#39;/&#39;)
def hello_world():
    return &#39;hello world!&#39;


if __name__ == &#39;__main__&#39;:
    hello_world.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;运行flask-helloworld-service:f52343a2a46f58140124ef653bf998a9&#34;&gt;运行Flask HelloWorld Service&lt;/h2&gt;

&lt;p&gt;直接运行次文件就可以了&lt;/p&gt;

&lt;h2 id=&#34;使用ab-进行简单的性能测试:f52343a2a46f58140124ef653bf998a9&#34;&gt;使用AB 进行简单的性能测试&lt;/h2&gt;

&lt;p&gt;AB的脚本如下： -n 表述总数，－c 表述并发&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# $1 is a parameter for java or python to record different performance result
ab -n 3000 -c 30 http://127.0.0.1:8080/ &amp;gt; $1-3K-30C.txt
ab -n 6000 -c 50 http://127.0.0.1:8080/ &amp;gt; $1-6K-50C.txt
ab -n 12000 -c 100 http://127.0.0.1:8080/ &amp;gt; $1-12K-100C.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后的结果：&lt;/p&gt;

&lt;p&gt;30 Currents:&lt;/p&gt;

&lt;p&gt;SpringBoot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Concurrency Level:      30
Time taken for tests:   5.828 seconds
Complete requests:      3000
Failed requests:        0
Total transferred:      522000 bytes
HTML transferred:       36000 bytes
Requests per second:    514.71 [#/sec] (mean)
Time per request:       58.285 [ms] (mean)
Time per request:       1.943 [ms] (mean, across all concurrent requests)
Transfer rate:          87.46 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0   42 443.0      2    5092
Processing:     0    4   2.7      4      19
Waiting:        0    3   2.4      3      19
Total:          1   46 442.9      6    5100

Percentage of the requests served within a certain time (ms)
  50%      6
  66%      7
  75%      8
  80%      9
  90%     12
  95%     15
  98%     19
  99%     30
 100%   5100 (longest request)


 Concurrency Level:      50
Time taken for tests:   1.161 seconds
Complete requests:      6000
Failed requests:        0
Total transferred:      1044000 bytes
HTML transferred:       72000 bytes
Requests per second:    5166.09 [#/sec] (mean)
Time per request:       9.678 [ms] (mean)
Time per request:       0.194 [ms] (mean, across all concurrent requests)
Transfer rate:          877.83 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    3   2.4      3      18
Processing:     1    6   3.3      6      32
Waiting:        0    5   3.0      4      30
Total:          3   10   4.0      8      33

Percentage of the requests served within a certain time (ms)
  50%      8
  66%      9
  75%     11
  80%     11
  90%     14
  95%     17
  98%     24
  99%     27
 100%     33 (longest request)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Flask: Current Level 100的时候没有timeout出现，不过springboot有而不能完成实验.
在100个并发前，SpringBoot比Flask略快，但是不知道什么原因springboot在100个并发的时候不能完成，这个会在后续使用中再做分析&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Concurrency Level:      30
Time taken for tests:   2.598 seconds
Complete requests:      3000
Failed requests:        0
Total transferred:      498000 bytes
HTML transferred:       36000 bytes
Requests per second:    1154.77 [#/sec] (mean)
Time per request:       25.979 [ms] (mean)
Time per request:       0.866 [ms] (mean, across all concurrent requests)
Transfer rate:          187.20 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.1      0       3
Processing:     1   26   5.8     24      67
Waiting:        1   26   5.7     24      67
Total:          2   26   5.8     24      67

Percentage of the requests served within a certain time (ms)
  50%     24
  66%     25
  75%     25
  80%     27
  90%     32
  95%     37
  98%     45
  99%     52
 100%     67 (longest request)

 Concurrency Level:      50
 Time taken for tests:   4.731 seconds
 Complete requests:      6000
 Failed requests:        0
 Total transferred:      996000 bytes
 HTML transferred:       72000 bytes
 Requests per second:    1268.30 [#/sec] (mean)
 Time per request:       39.423 [ms] (mean)
 Time per request:       0.788 [ms] (mean, across all concurrent requests)
 Transfer rate:          205.60 [Kbytes/sec] received

 Connection Times (ms)
               min  mean[+/-sd] median   max
 Connect:        0    0   0.2      0       3
 Processing:     2   39   3.2     39      50
 Waiting:        2   39   3.2     39      50
 Total:          5   39   3.1     39      50

 Percentage of the requests served within a certain time (ms)
   50%     39
   66%     40
   75%     40
   80%     40
   90%     41
   95%     46
   98%     48
   99%     49
  100%     50 (longest request)

  Concurrency Level:      100
  Time taken for tests:   32.135 seconds
  Complete requests:      12000
  Failed requests:        0
  Total transferred:      1992000 bytes
  HTML transferred:       144000 bytes
  Requests per second:    373.43 [#/sec] (mean)
  Time per request:       267.790 [ms] (mean)
  Time per request:       2.678 [ms] (mean, across all concurrent requests)
  Transfer rate:          60.54 [Kbytes/sec] received

  Connection Times (ms)
                min  mean[+/-sd] median   max
  Connect:        0  167 1816.4      0   20069
  Processing:     1  101 149.1     74    1559
  Waiting:        1  100 149.0     74    1559
  Total:          1  267 1816.7     75   20070

  Percentage of the requests served within a certain time (ms)
    50%     75
    66%     79
    75%     81
    80%     86
    90%     98
    95%    180
    98%    720
    99%   1543
   100%  20070 (longest request)

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>docker usage: container</title>
      <link>http://simonpatrick.github.io/posts/microservice/2015-12-28-docker-usage-container/</link>
      <pubDate>Mon, 28 Dec 2015 22:08:39 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/microservice/2015-12-28-docker-usage-container/</guid>
      <description>

&lt;p&gt;Docker container 的常用命令。&lt;/p&gt;

&lt;h2 id=&#34;docker-information:7dfb2af45e3c882d18840d2076c9632a&#34;&gt;Docker information&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker info
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果docker没有安装，则下载docker tools,如果权限不过就使用如下方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 如果还没有docker group就添加一个：
$ sudo groupadd docker
# 将用户加入该group内。然后退出并重新登录即可生效。
$ sudo gpasswd -a ${USER} docker
# 重启docker
$ sudo service docker restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;working-with-docker:7dfb2af45e3c882d18840d2076c9632a&#34;&gt;working with docker&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Usage:  [sudo] docker [flags] [command] [arguments] ..
# Example:
$ docker run -i -t ubuntu /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;运行交互shell:7dfb2af45e3c882d18840d2076c9632a&#34;&gt;运行交互shell&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo docker run -i -t ubuntu /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;绑定docker到另外的主机-端口或者unix-socket:7dfb2af45e3c882d18840d2076c9632a&#34;&gt;绑定Docker到另外的主机/端口或者Unix socket&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker -H 0.0.0.0:5555 -d &amp;amp;
sudo docker -H :5555 pull ubuntu
# 进程模式下运行docker
$ sudo &amp;lt;path to&amp;gt;/docker -H tcp://127.0.0.1:2375 -H unix:///var/run/docker.sock -d &amp;amp;
# 使用默认的unix socker来下载ubuntu镜像
$ sudo docker pull ubuntu
# 或者使用TCP端口
$ sudo docker -H tcp://127.0.0.1:2375 pull ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;开始一个长时间运行的工作进程:7dfb2af45e3c882d18840d2076c9632a&#34;&gt;开始一个长时间运行的工作进程&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# 开始一个非常有用的长时间运行的进程
$ JOB=$(sudo docker run -d ubuntu /bin/sh -c &amp;quot;while true; do echo Hello world; sleep 1; done&amp;quot;)

# 到目前为止收集的输出工作
$ sudo docker logs $JOB

# 关闭这项进程
$ sudo docker kill $JOB

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;列出容器:7dfb2af45e3c882d18840d2076c9632a&#34;&gt;列出容器&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ sudo docker ps # Lists only running containers
$ sudo docker ps -a # Lists all containers
$ sudo docker ps -l # List the last running container
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;控制容器:7dfb2af45e3c882d18840d2076c9632a&#34;&gt;控制容器&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# 开始一个新的容器
$ JOB=$(sudo docker run -d ubuntu /bin/sh -c &amp;quot;while true; do echo Hello world; sleep 1; done&amp;quot;)

# 停止容器
$ docker stop $JOB

# 开始容器
$ docker start $JOB

# 重启容器
$ docker restart $JOB

# 杀死一个工作
$ docker kill $JOB

# 删除一个容器
$ docker stop $JOB # Container must be stopped to remove it
$ docker rm $JOB
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;绑定服务到tcp端口:7dfb2af45e3c882d18840d2076c9632a&#34;&gt;绑定服务到TCP端口&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#让容器绑定4444端口，并通知netcat监听它。
$ JOB=$(sudo docker run -d -p 4444 ubuntu:12.10 /bin/nc -l 4444)

# 查看容器转发的公共端口
$ PORT=$(sudo docker port $JOB 4444 | awk -F: &#39;{ print $2 }&#39;)

# 连接这个公共端口
$ echo hello world | nc 127.0.0.1 $PORT

# 确认网络连接工作
$ echo &amp;quot;Daemon received: $(sudo docker logs $JOB)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;delete-docker-images:7dfb2af45e3c882d18840d2076c9632a&#34;&gt;Delete Docker images&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# 停止所有容器
$ docker stop $(docker ps -a -q)

# 删除指定镜像
$ docker rmi $image

# 删除无标示镜像，即id为&amp;lt;None&amp;gt;的镜像
$ docker rmi $(docker images | grep &amp;quot;^&amp;lt;none&amp;gt;&amp;quot; | awk &amp;quot;{print $3}&amp;quot;)

# 删除所有镜像
$ docker rmi $(docker images -q)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>docker usage: images</title>
      <link>http://simonpatrick.github.io/posts/microservice/2015-12-28-docker_usage/</link>
      <pubDate>Mon, 28 Dec 2015 21:49:22 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/microservice/2015-12-28-docker_usage/</guid>
      <description>

&lt;p&gt;Some Basic Command usage for docker&lt;/p&gt;

&lt;h2 id=&#34;images:65b936b4fd2aed22df3e20d247c1bfe3&#34;&gt;images&lt;/h2&gt;

&lt;p&gt;大部分的命令就是如下的思路：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# install image
docker pull image_name
# search image
docker search &amp;lt;image_name&amp;gt;
# get images
docker images
# run images as a container
docker -it &amp;lt;image_name&amp;gt; &amp;lt;command&amp;gt;
# example:
docker run -t -i ubuntu:12.04 /bin/bash
# commit changes
docker commit -m=&amp;quot;added what&amp;quot; -a=&amp;quot;author_name&amp;quot; &amp;lt;image_id&amp;gt; &amp;lt;new_image_name&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dockerfile:65b936b4fd2aed22df3e20d247c1bfe3&#34;&gt;Dockerfile&lt;/h2&gt;

&lt;p&gt;Dockerfile是申明docker container的一个文件，通过此文件来描述今镜像（image）的属性.&lt;/p&gt;

&lt;p&gt;Dockerfile的每一个指令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;INSTRUCTION statement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker build:
我们使用 docker build 命令并指定 -t 标识(flag)来标示属于 ouruser ，镜像名称为 sinatra,标签是 v2。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t ouruser/sinatra:v2 .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;run as container:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; docker run -t -i ouruser/sinatra:v2 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;remove-image:65b936b4fd2aed22df3e20d247c1bfe3&#34;&gt;remove image&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;docker rmi &amp;lt;image_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>microservice-from-stackoverflow</title>
      <link>http://simonpatrick.github.io/posts/microservice/2015-12-02-microservice-from-stackoverflow/</link>
      <pubDate>Wed, 02 Dec 2015 23:49:28 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/microservice/2015-12-02-microservice-from-stackoverflow/</guid>
      <description>&lt;p&gt;一篇stackoverflow上面关于microservice的问答，觉得挺适合我自己的，刚好也比较感兴趣，就先留个位置
&lt;a href=&#34;http://stackoverflow.com/questions/29669180/microservice-service-registry-api-gateway-and-data-sharing?rq=1&#34;&gt;microservice-service-registry-api-gateway-and-data-sharing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇文章里面自己觉得需要进一步了解的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有一张图：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;../../assets/images/pics/microservice_diagram.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非HTTP协议的通信(AMQP&amp;hellip;&amp;hellip;)&lt;/li&gt;
&lt;li&gt;HATEOAS pattern&lt;/li&gt;
&lt;li&gt;Service Registries like Zookeeper,Eureka&lt;/li&gt;
&lt;li&gt;tools like Netflix&amp;rsquo;s Hystrix helps to fallback&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Docker 解释</title>
      <link>http://simonpatrick.github.io/posts/microservice/2015-11-04-Docker-Notes/</link>
      <pubDate>Wed, 04 Nov 2015 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/microservice/2015-11-04-Docker-Notes/</guid>
      <description>

&lt;p&gt;Docker 基本概念的解释&lt;/p&gt;

&lt;h2 id=&#34;docker-dictionary-container:88007030b0efd0dd851727db1e604c38&#34;&gt;Docker dictionary - Container&lt;/h2&gt;

&lt;p&gt;Docker Container is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A running instance of your app and it’s complete software stack&lt;/li&gt;
&lt;li&gt;Often runs just one process&lt;/li&gt;
&lt;li&gt;You might have many identical containers running&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;docker-dictionary-image:88007030b0efd0dd851727db1e604c38&#34;&gt;Docker dictionary - image&lt;/h2&gt;

&lt;p&gt;Docker Image is:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Docker uses a layering system to optimize storage&lt;/li&gt;
&lt;li&gt;Each line in your Dockerfile is a layer&lt;/li&gt;
&lt;li&gt;Many layers make up an image&lt;/li&gt;
&lt;li&gt;Images share common layers where possible&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;docker-dictionary-dockerfile:88007030b0efd0dd851727db1e604c38&#34;&gt;Docker dictionary - Dockerfile&lt;/h2&gt;

&lt;p&gt;￼Docker Dictionary - Dockerfile&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Dockerfile is a text file that lives in your project root&lt;/li&gt;
&lt;li&gt;Describes how to build your image&lt;/li&gt;
&lt;li&gt;Installs software packages, configures runtimes, etc&lt;/li&gt;
&lt;li&gt;Tells Docker what command to run and what ports to open&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;docker-dictionary-registry:88007030b0efd0dd851727db1e604c38&#34;&gt;￼Docker Dictionary - Registry&lt;/h2&gt;

&lt;p&gt;Docker Dictionary - Registry&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A server that stores images&lt;/li&gt;
&lt;li&gt;Provides organization and authentication as needed&lt;/li&gt;
&lt;li&gt;Facilitates sharing of pre-built images&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;docker-binary:88007030b0efd0dd851727db1e604c38&#34;&gt;Docker Binary&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Both the CLI client and the server&lt;/li&gt;
&lt;li&gt;Written in Go&lt;/li&gt;
&lt;li&gt;Speaks REST-ish over Unix socket or TCP/SSL&lt;/li&gt;
&lt;li&gt;CLI and server can be on different hosts&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;docker-building-images:88007030b0efd0dd851727db1e604c38&#34;&gt;Docker Building Images&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;../../assets/images/pics/docker_building.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;how-containers-run:88007030b0efd0dd851727db1e604c38&#34;&gt;How Containers run&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Docker daemon runs as root and starts containers&lt;/li&gt;
&lt;li&gt;Containers are basically stateless&lt;/li&gt;
&lt;li&gt;Can expose local storage if you need to&lt;/li&gt;
&lt;li&gt;Can’t see each other’s files&lt;/li&gt;
&lt;li&gt;State is gone on exit&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dockerfiles:88007030b0efd0dd851727db1e604c38&#34;&gt;Dockerfiles&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;FROM - specify your base image&lt;/li&gt;
&lt;li&gt;RUN - run commands in the context&lt;/li&gt;
&lt;li&gt;ADD - put your files in&lt;/li&gt;
&lt;li&gt;EXPOSE - listen on ports&lt;/li&gt;
&lt;li&gt;ENV - set enviroment vars&lt;/li&gt;
&lt;li&gt;VOLUME - persistent storage&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tools-chain:88007030b0efd0dd851727db1e604c38&#34;&gt;Tools Chain&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Vagrant&lt;/li&gt;
&lt;li&gt;systemd&lt;/li&gt;
&lt;li&gt;CoreOS&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>