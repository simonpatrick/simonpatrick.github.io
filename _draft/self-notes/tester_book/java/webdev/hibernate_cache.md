# Hibernate Cache 
- Hibernate 一级缓存 Session缓存
- Hibernate 二级缓存 
- 查询缓存
- 二级缓存高级应用（分布式缓存）

Hibernate缓存介于Hibernate应用和数据库之间，缓存中存放了数据库数据的拷贝。 其作用是减少访问数据库的频率，从而提高应用的运行性能。
Hibernate在进行读取数据的时候，根据缓存机制在相应的缓存中查询，如果在缓存中找到了需要的数据(我们把这称做“缓存命中”)，则就直接把命中的数据作为结果加以利用，避免的了建立数据库查询的性能损耗。

Hibernate缓存：

- 一级缓存： Session级别的缓存
- 二级缓存： SessionFactory级别的全局缓存

缓存的范围

- 事务范围（一级缓存就属于事务范围）
- 进程范围
缓存被进程范围内的所有事务共享。这些事务有可能并发访问缓存，因此必须对缓存采取必要的事务隔离机制。缓存的生命周期依赖于进程的生命周期，进程结束时，缓存也就结束了生命周期。它的物理介质可以是内存或硬盘
- 集群范围
在集群环境中，缓存被一个机器或者多个机器的进程共享。缓存中的数据被复制到集群环境中的每个进程节点，进程间通过远程通信来保证缓存中的数据的一致性，缓存中的数据通常采用对象的松散数据形式。

## Hibernate 一级缓存 Session缓存

Session具有一个缓存，是一块内存空间，在这个内存空间存放了相互关联的java对象，这种位于Session缓存内的对象也被称为持久化对象，Session负责根据持久化对象的状态变化来同步更新数据库。Session的缓存是内置的，不能被卸除的，也被称为Hibernate的第一级缓存。在正常的情况下一级缓存是由Hibernate自动维护的，无需人工干预。

Hibernate如何维护一级缓存

* save,saveOrUpdate,update(),如果对象不存在，就加入到Hibernate的Session里面
* load(),list,iterator,get,query时也是一样
* session close的时候缓存消失
* java对象在Hibernate中的状态
	- 临时状态 新对象刚创建，session内存外
	- 持久状态 已被持久化，在session内 
	- 删除状态 准备删除，在session外
	- 游离状态 已经持久化，不再使用，在session外
* Hibernate session 接口
	- get()/load()
	- save()/persist()
	- update()/merge()
	- saveOrUpdate
	- delete()
	- close()
* 清理缓存
	- 检查数据库是否和缓存对象一致，然后更新数据库
	- 新对象进入session有一份备份，清理缓存时检查当前对象是否和备份对象一致，如果不一致则更新数据库
	- evict(object) 清除指定对象
	- clear()清除所有对象
	- 在事务commit前执行
	- 查询发现持久化对象发生变化，就更新数据库
	- flush()
* Hibernate 二级缓存
	- ehcache
	- jbosscache
	- oscache
* 并发策略
- 事务型
仅在受管理的环境中适用
提供Repeatable Read事务隔离级别
适用经常被读，很少修改的数据
可以防止脏读和不可重复读的并发问题
缓存支持事务，发生异常的时候，缓存也能够回滚
- read-write
提供Read Committed事务隔离级别
在非集群的环境中适用
适用经常被读，很少修改的数据
可以防止脏读
更新缓存的时候会锁定缓存中的数据
- nonstrict-read
适用极少被修改，偶尔允许脏读的数据（两个事务同时修改数据的情况很少见）
不保证缓存和数据库中数据的一致性
为缓存数据设置很短的过期时间，从而尽量避免脏读
不锁定缓存中的数据
- read-only
适用从来不会被修改的数据（如参考数据）
在此模式下，如果对数据进行更新操作，会有异常
事务隔离级别低，并发性能高
在集群环境中也能完美运作
- 

