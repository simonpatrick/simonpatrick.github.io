<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Testing on Colored Hedwig</title>
    <link>http://simonpatrick.github.io/tags/testing/</link>
    <description>Recent content in Testing on Colored Hedwig</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 05 Jan 2016 23:37:49 +0000</lastBuildDate>
    <atom:link href="http://simonpatrick.github.io/tags/testing/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>sql injection, sql 注入</title>
      <link>http://simonpatrick.github.io/posts/testing/2016-01-05-sql-injection/</link>
      <pubDate>Tue, 05 Jan 2016 23:37:49 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/testing/2016-01-05-sql-injection/</guid>
      <description>

&lt;p&gt;SQL注入的问题由来以久,主要是针对于一些系统时通过拼接SQL的方式来处理程序.以下是关于JAVA WEB的一些SQL注入的介绍.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.owasp.org/index.php/Preventing_SQL_Injection_in_Java&#34;&gt;来源OWASP&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;什么是sql注入:e945a6473403ff74947fb6df2db9baa1&#34;&gt;什么是SQL注入&lt;/h2&gt;

&lt;p&gt;SQL injection vulnerabilities allow an attacker to inject (or execute) SQL commands within an application.
大意就是攻击者可以通过修改页面请求来执行sql达到自己的目的，比如拉数据，或者恶意的修改数据等等.&lt;/p&gt;

&lt;h2 id=&#34;sql-注入例子:e945a6473403ff74947fb6df2db9baa1&#34;&gt;SQL 注入例子&lt;/h2&gt;

&lt;p&gt;一下例子是有SQL注入漏洞的一段程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt;conn = pool.getConnection( );
String sql = &amp;quot;select * from user where username=&#39;&amp;quot; + username +&amp;quot;&#39; and password=&#39;&amp;quot; + password + &amp;quot;&#39;&amp;quot;;
stmt = conn.createStatement();
rs = stmt.executeQuery(sql);
if (rs.next()) {
loggedIn = true;
	out.println(&amp;quot;Successfully logged in&amp;quot;);
} else {
	out.println(&amp;quot;Username and/or password not recognized&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于SQL是拼接的，所有如果用户直接食用username，或者password中 使用了如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt;admin&#39; OR &#39;1&#39;=&#39;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后执行的SQL就是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt;select * from user where username=&#39;admin&#39; OR &#39;1&#39;=&#39;1&#39; and password=&#39; &#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明显，这样就会把所有的用户信息拿到了&lt;/p&gt;

&lt;h2 id=&#34;防范措施-defense-strategy:e945a6473403ff74947fb6df2db9baa1&#34;&gt;防范措施 Defense Strategy&lt;/h2&gt;

&lt;p&gt;prevent SQL injection:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All queries should be parametrized.&lt;/li&gt;
&lt;li&gt;All dynamic data should be explicitly bound to parametrized queries.&lt;/li&gt;
&lt;li&gt;String concatenation should never be used to create dynamic SQL.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;parameterized-queries-stored-procedures:e945a6473403ff74947fb6df2db9baa1&#34;&gt;Parameterized Queries／Stored Procedures&lt;/h2&gt;

&lt;p&gt;参数化SQL，使用prepareStatement&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt;String selectStatement = &amp;quot;SELECT * FROM User WHERE userId = ? &amp;quot;;
PreparedStatement prepStmt = con.prepareStatement(selectStatement);
prepStmt.setString(1, userId);
ResultSet rs = prepStmt.executeQuery();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存储过程基本上能够防止SQL注入&lt;/p&gt;

&lt;h2 id=&#34;hibernate-mybatis:e945a6473403ff74947fb6df2db9baa1&#34;&gt;Hibernate/MyBatis&lt;/h2&gt;

&lt;p&gt;不要以为使用了ORM框架就没有SQL注入，其实不当使用也会有的.比如:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hibernate native SQL&lt;/li&gt;
&lt;li&gt;order by 没法使用绑定变量&lt;/li&gt;
&lt;li&gt;动态表名也无法使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;owasp-java-project:e945a6473403ff74947fb6df2db9baa1&#34;&gt;OWASP JAVA Project&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.owasp.org/index.php/Category:OWASP_Java_Project#tab=Project_and_OWASP_Resources&#34;&gt;OWASP_Java_Project&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>静态代码检查</title>
      <link>http://simonpatrick.github.io/posts/testing/2016-01-05-static-code-analysis/</link>
      <pubDate>Tue, 05 Jan 2016 23:00:55 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/testing/2016-01-05-static-code-analysis/</guid>
      <description>

&lt;p&gt;静态代码检查有利于提高代码质量，同时也可以快速的发现一些问题. 常用的静态代码检查有一下几种，
checkstyle，pmd，findbugs. 刚好公司需要做一个mybatis SQL注入的检查，所以收集了一下关于这三个工具使用的介绍&lt;/p&gt;

&lt;h2 id=&#34;checkstyle-pmd-findbugs-的是使用介绍:b3b756f5fbe7139e7e22096adcb7bf61&#34;&gt;checkstyle,PMD,findbugs 的是使用介绍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;checkstyle&lt;/strong&gt; enforce coding conventions and standards in code, missing/improper javadoc, naming conventions, placement of braces and parentheses, whitespace, line length, etc&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PMD&lt;/strong&gt; detect bad practices,PMD 支持不同语言，如JAVA，Ruby，XML等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;findbugs&lt;/strong&gt; really find potential bugs,比如NPE，equals，hashcode等的用法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考文章：
&lt;a href=&#34;http://tirthalpatel.blogspot.com/2014/01/static-code-analyzers-checkstyle-pmd-findbugs.html&#34;&gt;checkstyle vs pmd vs findbugs&lt;/a&gt;
&lt;a href=&#34;http://www.sonarqube.org/sonar-to-identify-security-vulnerabilities/&#34;&gt;sonar security&lt;/a&gt;
&lt;a href=&#34;https://www.sparkred.com/blog/open-source-java-static-code-analyzers/&#34;&gt;checkstyle vs pmd vs findbugs 2&lt;/a&gt;
&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-findbug1/&#34;&gt;findbugs&lt;/a&gt;
&lt;a href=&#34;http://findbugs.sourceforge.net/bugDescriptions.html?cm_mc_uid=11877464828514517953725&amp;amp;cm_mc_sid_50200000=1452010453&#34;&gt;findbugs bugs&lt;/a&gt;
&lt;a href=&#34;http://findbugs.sourceforge.net/index.html&#34;&gt;find bugs home page&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>tomcat_basic</title>
      <link>http://simonpatrick.github.io/posts/testing/2015-12-23-tomcat_basic/</link>
      <pubDate>Wed, 23 Dec 2015 20:46:28 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/testing/2015-12-23-tomcat_basic/</guid>
      <description>&lt;p&gt;Tomcat 是我们常用的一个servlet容器，所以学点TOMCAT的知识对于如何了解一些TOMCAT的内幕也会比较好理解.
一下是网上看到的一片非常不错的文章:
&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/&#34;&gt;Tomcat-1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>收集性能测试需求</title>
      <link>http://simonpatrick.github.io/posts/testing/2015-12-08-collect-performance-requirement/</link>
      <pubDate>Tue, 08 Dec 2015 13:36:27 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/testing/2015-12-08-collect-performance-requirement/</guid>
      <description>&lt;p&gt;很多时候遇到一些关于性能测试的需求的时候，需求方实际上是给不出任何具体的需求，更多的是一下如下的抱怨:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;速度慢(具体哪个操作慢又很难给出)&lt;/li&gt;
&lt;li&gt;经常会出现系统过载(一般也不会自己看看监控的)&lt;/li&gt;
&lt;li&gt;反正就是慢，我也不知道哪里慢&lt;/li&gt;
&lt;li&gt;有一天突然系统响应时间慢，监控报警了&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;遇到这样的问题时,突然发现测试其实挺悲惨的,因为和这样的同事打交道其实压力挺大了.按照这样的逻辑
其实背后的含义就是所有和测试有关的事情都是你测试的事情，然后当坐下来和他们沟通的时候，他们具体
的问题时，一般也很难收集到信息，我一般会问一下如下的问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这个慢是经常出现的吗，还是那天突然有些运维的改动或者有些其他系统故障造成的？
我至少遇到过几次犹豫数据库的原因造成了整个系统都出问题了,然而还是会有人会提出这样的不叫思考的要求，响应慢了，你一定要去测性能。 回到问题本身来说，我已经遇到无数次问这样的问题的时候，答案是不知道；我一般还会去查看一个月，或者更长的时间来看应用的响应时间分布，看看有没有明显的变慢点&lt;/li&gt;
&lt;li&gt;同时会问能不能具体到那个API或者页面访问的时候慢，同样没有答案；答案就是确实慢，但是不知道那个业务慢，所以才要你来测试一下，然一个应用可能有数十个API，我们总是要了解客户使用场景的吧&lt;/li&gt;
&lt;li&gt;相关业务在某个时间段有没有特殊的并发操作，比如可能每个月底的时候需要突击一个什么东西，然后突然访问量就变大了，这样好歹也能推测一些访问的场景来看看，然获取的答案还是不知道&lt;/li&gt;
&lt;li&gt;你对于你自己应用大概需要的吞吐量是多少，或者具体到某些具体的API是多少？ 然还是没有答案&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;诸如此类的问题其实经常是得不到回答的，而你有需要完成相关的性能测试和排查.唯一的好处就是你不要太当真，大家只是在踢这个球而已。不过既然做了技术，而且想做这个性能测试的话，只能自己想想办法去获得了一些数据了.一般需要如下数据：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最高峰1个小时的访问量&lt;/li&gt;
&lt;li&gt;最高峰一个小时的PAGE VIEW&lt;/li&gt;
&lt;li&gt;最高峰一个小时的交易量(transaction量)，converation rate from visits&lt;/li&gt;
&lt;li&gt;APIs最高峰1个小时的访问量&lt;/li&gt;
&lt;li&gt;业务方对于活动人数的估计&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然还有一些其他的应用的访问量，就不一一说明了,后面会再用一些数据计算来说明输入估算性能需求.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>软件容错</title>
      <link>http://simonpatrick.github.io/posts/testing/2015-11-16-error_toleration/</link>
      <pubDate>Mon, 16 Nov 2015 23:24:33 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/testing/2015-11-16-error_toleration/</guid>
      <description>

&lt;p&gt;软件的世界已经变的及其复杂，在互联网的世界中一个个知道不知道的API将世界连接起来，如蜘蛛网一般,一个看的到的功能可能依赖了好几个看不到的API,所以中间出点错误实在不能说是个意外了。但是出错归出错，出错了软件也是一样要处理这些问题，下面就讲讲我学到遇到的一点容错的小知识。&lt;/p&gt;

&lt;h2 id=&#34;容错的目标:8f26f23e8eee10c0bffd1a0f814908f4&#34;&gt;容错的目标&lt;/h2&gt;

&lt;p&gt;降低或者最小化对系统可用性，可靠性的影响，举个例子来说就是单点故障，如果一个地方出现错误
而把整个系统网络都拖垮了，这个显然是不能接受的。可以用一下几个来形容错误：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;fault(缺陷) 一些bug&lt;/li&gt;
&lt;li&gt;error(错误) 一些业务无法正常执行&lt;/li&gt;
&lt;li&gt;failure(故障) 业务较长时间无法正常执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;容错的方法:8f26f23e8eee10c0bffd1a0f814908f4&#34;&gt;容错的方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;硬件容错：多备份,系统冗余，主备&lt;/li&gt;
&lt;li&gt;软件容错：避免严重业务错误，降级，异常处理,侦测，监控，重启&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;li&gt;系统容错&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;常见机遇鲁棒性:8f26f23e8eee10c0bffd1a0f814908f4&#34;&gt;常见机遇鲁棒性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Process Pairs&lt;/li&gt;
&lt;li&gt;Graceful Degradation:降级&lt;/li&gt;
&lt;li&gt;Selective Retry&lt;/li&gt;
&lt;li&gt;state handling&lt;/li&gt;
&lt;li&gt;Linking Process&lt;/li&gt;
&lt;li&gt;Rejuvenation: 不可重现问题&lt;/li&gt;
&lt;li&gt;Checkpoint&lt;/li&gt;
&lt;li&gt;update lost&lt;/li&gt;
&lt;li&gt;application state scrubbing&lt;/li&gt;
&lt;li&gt;process pools&lt;/li&gt;
&lt;li&gt;recovery block&lt;/li&gt;
&lt;li&gt;micro reboot&lt;/li&gt;
&lt;li&gt;state correction&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>测试用例-一些有意思的工具</title>
      <link>http://simonpatrick.github.io/posts/thoughts/2015-11-03-Test-Tools/</link>
      <pubDate>Wed, 04 Nov 2015 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/thoughts/2015-11-03-Test-Tools/</guid>
      <description>

&lt;h2 id=&#34;automation-test-case-generate-tools:b5821be488246679c2205cacd3be8aff&#34;&gt;Automation Test Case Generate Tools&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://korat.sourceforge.net/&#34;&gt;Korat(structurally complex tests)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/randoop/randoop&#34;&gt;Randoop (random testing)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/CERTCC-Vulnerability-Analysis/certfuzz&#34;&gt;CERT Basic Fuzzing Framework&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/samhocevar/zzuf.git&#34;&gt;ZZUF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cert.org/vulnerability-analysis/tools/triage.cfm?&#34;&gt;cert.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/osate&#34;&gt;osate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://mit.bme.hu/~micskeiz/pages/code_based_test_generation.html&#34;&gt;link&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>测试用例设计- 随机指定一个产品的测试</title>
      <link>http://simonpatrick.github.io/posts/thoughts/2015-10-22-Random-TestCaseDesign/</link>
      <pubDate>Thu, 22 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/thoughts/2015-10-22-Random-TestCaseDesign/</guid>
      <description>

&lt;p&gt;有时面试的时候会随机指定一个产品进行测试,比如一个电梯,你会如何设计测试用例？这个问题很发散,更多的是看应聘者的条理
和分析能力.&lt;/p&gt;

&lt;p&gt;本质上一个电梯是一个太大的范畴，实际测试的过程中很少一下子会有这么巨大的功能让你测试的。
与其说让你设计测试用例，其实好不如说让你想一个电梯有什么功能,然后根据功能再来考虑测试用例,所以更多的
是考察思路,在实际的测试工作中,如果突然有个人说我今天完成了一个电梯的功能,找个人给我测一下吧。
那么多半这个项目就是个让测试欲哭无泪的项目。&lt;/p&gt;

&lt;p&gt;不过既然面试有人问这样的问题，那么就分析分析吧，以下我是把电梯转化为类似互联网产品来做的分析，
完全是个人想法,一定有非常多欠缺。&lt;/p&gt;

&lt;h2 id=&#34;后端服务组件和客户端分离-client-server-mvc:2d7d5581ce090c319d7e70f8706405e8&#34;&gt;后端服务组件和客户端分离(Client-Server/MVC)&lt;/h2&gt;

&lt;p&gt;首先其实对把一个电梯分成不同的组件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;驱动服务: 可以使电梯上下行(后台服务)&lt;/li&gt;
&lt;li&gt;门: 开门关门(后台服务)&lt;/li&gt;
&lt;li&gt;电梯操作面板: 人机界面,担当用户和电梯的一个中间人作用,将用户操作转化为指令来控制电梯 (app/web page)
(如果简单的话可能操作命令转换就都在这个地方了，如果复杂可能还有一个控制系统层)&lt;/li&gt;
&lt;li&gt;指令控制系统(调度系统,监听器或者Queue)&lt;/li&gt;
&lt;li&gt;呼叫监控系统:(可以暂时不考虑)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里就先考虑简单的情况，电梯操作面板模块之内将操作转换成指令给电梯的驱动和门服务&lt;/p&gt;

&lt;h2 id=&#34;逐个组件来考虑用例:2d7d5581ce090c319d7e70f8706405e8&#34;&gt;逐个组件来考虑用例&lt;/h2&gt;

&lt;h3 id=&#34;驱动服务可能包含的功能点有如下:2d7d5581ce090c319d7e70f8706405e8&#34;&gt;驱动服务可能包含的功能点有如下:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;上行, 但是上行有极限位置(可配置)，按照指定步进数量上行&lt;/li&gt;
&lt;li&gt;中途等待&lt;/li&gt;
&lt;li&gt;步进距离(一层距离)可以配置&lt;/li&gt;
&lt;li&gt;下行,下行位置(可配置)，按照指定步进数量下行&lt;/li&gt;
&lt;li&gt;承载重量&lt;/li&gt;
&lt;li&gt;可靠性监测，使用寿命监测&lt;/li&gt;
&lt;li&gt;故障监测&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里注意如果测试电梯产品和测试指定某个大楼的电梯,测试用例的设计考虑点是稍有不同的，如果是电梯产品他就有电梯的配置项需要测试，
如果是测试制定电梯,那么配置项就可以忽略了，配置的就是你目前的配置。&lt;/p&gt;

&lt;h3 id=&#34;门服务:2d7d5581ce090c319d7e70f8706405e8&#34;&gt;门服务&lt;/h3&gt;

&lt;p&gt;关于门的服务可能会想到的是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;开门&lt;/li&gt;
&lt;li&gt;关门&lt;/li&gt;
&lt;li&gt;可靠性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于开门这个功能的测试用例测试可以围绕:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;接收到开门指令开门并且只做开门&lt;/li&gt;
&lt;li&gt;在电梯运动过程中接收到开门指令不开门&lt;/li&gt;
&lt;li&gt;接收不到开门指令则不开门&lt;/li&gt;
&lt;li&gt;开门指令被中断&lt;/li&gt;
&lt;li&gt;开门接到后的进行开门的响应时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关门是类似，但是关门需要考虑超重情况下不能关门.
可靠性考虑多少次开门关门之后开门关门的机械组件才失效&lt;/p&gt;

&lt;h3 id=&#34;电梯操作面板:2d7d5581ce090c319d7e70f8706405e8&#34;&gt;电梯操作面板&lt;/h3&gt;

&lt;p&gt;操作面板这块实际上分为界面控件状态改变和指令转换两大块,在通过操作操作面板按钮后，同时
改变按钮状态以及发送正确指令,而指令处理这块就可
- 门开关按钮, 开关有效,开关无效
- 楼层按钮，启用,取消，灯亮，灯关
- 电梯上下调度, 多个按钮被按下之后,结合电梯自己所在位置决定运行方案
- 易用性等，因为是见人的地方，所有就有usability 测试&lt;/p&gt;

&lt;h3 id=&#34;指令控制系统:2d7d5581ce090c319d7e70f8706405e8&#34;&gt;指令控制系统&lt;/h3&gt;

&lt;p&gt;指令控制系统可以认为根据电梯运行时的上下文,调度电梯运行的一个模块,这里面应该是根据某种规则
发出实际控制电梯的信号，具体什么的规则其实很难断定。&lt;/p&gt;

&lt;h3 id=&#34;扩展到多个电梯的调度测试:2d7d5581ce090c319d7e70f8706405e8&#34;&gt;扩展到多个电梯的调度测试&lt;/h3&gt;

&lt;p&gt;有可能会有多个电梯的调度，同样也是需要一套规则再来进行测试的&lt;/p&gt;

&lt;p&gt;这个文章写的有点粗糙,主要凭空去想这些case太伤脑袋，但是总体而言个人认为这是一个考虑问题的方向，同时个人觉得在一个短时间内
针对这样一个系统说写出很多测试用例，其实也就是呵呵了。
也许有更好的方法来总结这样的测试,可能类似于探索性测试之类的，希望有人能够指正。
同时我们也可以看到设计测试用例要包含多少东西,测试需要了解:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;产品需求(没有需要推测:))&lt;/li&gt;
&lt;li&gt;功能&lt;/li&gt;
&lt;li&gt;可靠性&lt;/li&gt;
&lt;li&gt;性能&lt;/li&gt;
&lt;li&gt;扩展性&lt;/li&gt;
&lt;li&gt;可用性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从high level看可能还有更多,这些一个人都可以搞定的话,这个人还是人吗?而在实际的工作中这些会有都
多少人都进行相关类型的测试？不说进行这样的测试，估计连衡量这些测试的优先级都不会,有人说的头头
是道，可是真的有多少实践呢？&lt;/p&gt;

&lt;p&gt;生活可能就是这样的,说的天花乱坠的,可能其实都是别人的经验,如果真的自己动手做的时候,就说需要找人做.
然后他就成为领导了.也有更大的领导在说一个什么事情的时候，就接入一个宏大的名词，然后大领导一听，对，
然后他也成了领导了. 而做事的人苦苦的寻觅着那些宏大名次的解答，更为关键的是,很可能是你一个人去寻找
很多宏大名词的解答.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>