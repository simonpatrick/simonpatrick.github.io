<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Refactoring on Colored Hedwig</title>
    <link>http://simonpatrick.github.io/tags/refactoring/</link>
    <description>Recent content in Refactoring on Colored Hedwig</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 03 Nov 2015 10:31:11 +0800</lastBuildDate>
    <atom:link href="http://simonpatrick.github.io/tags/refactoring/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Refactoring-8-remove God Class</title>
      <link>http://simonpatrick.github.io/posts/refactoring/2015-10-26-remove-god-class/</link>
      <pubDate>Tue, 03 Nov 2015 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/refactoring/2015-10-26-remove-god-class/</guid>
      <description>&lt;p&gt;God Class 就是一个类里面有一大堆不相干的方法放在一起,一般
情况下很多的工具类，或者manager有可能会有这样的情况.不是说不能有
工具类或者manager类，这个的关键是不相干的放在一个类里面。&lt;/p&gt;

&lt;p&gt;不相干就违反了Single Responsibility的原则.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Refactoring-1-Encapsulate Collection</title>
      <link>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-EncapsulateCollection/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-EncapsulateCollection/</guid>
      <description>

&lt;p&gt;关于重构的第一篇，后续会在这个话题继续讨论&lt;/p&gt;

&lt;h2 id=&#34;what-is-encapsulate-collection:f47f853c387c4c86b12d161b6497111a&#34;&gt;What is Encapsulate Collection&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;In certain scenarios it is beneficial to not expose a full collection to consumers of a class. Some of these circumstances is when there is additional logic associated with adding/removing items from a collection. Because of this reason, it is a good idea to only expose the collection as something you can iterate over without modifying the collection. Let’s take a look at some code
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种重构方式主要是将直接操纵集合类的操作直接暴露出简单的函数，同时修改函数名到
更有意义的名字&lt;/p&gt;

&lt;h2 id=&#34;code-sample:f47f853c387c4c86b12d161b6497111a&#34;&gt;Code Sample&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Order {
  private List&amp;lt;Item&amp;gt; itemList = Lists.newArrayList();

  public void addItem(Item item){
      itemList.add(item);
  }

  public void removeItem(final Item item){
      itemList.remove(item);
  }

  public void removeItems(List&amp;lt;Item&amp;gt; items){
      itemList.removeAll(items);
  }

  public int total(){
      return itemList.size();
  }

  public int distinctItemCount(){
      int result=0;
      List&amp;lt;String&amp;gt; itemNames=Lists.newArrayList();
      Set&amp;lt;String&amp;gt; names = Sets.newHashSet();
      itemList.stream().forEach(element -&amp;gt;
              names.add(element.getName()));
      return names.size();
  }
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于有什么好处的思考:f47f853c387c4c86b12d161b6497111a&#34;&gt;关于有什么好处的思考&lt;/h2&gt;

&lt;p&gt;考虑一下如上的写法有哪些好处呢？个人觉得：&lt;/p&gt;

&lt;p&gt;－ 将一些集合操作整合成函数，减少每个人不同写法出错
－ 将集合操作编程有意义的业务函数，提高了代码业务层的可读性&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Refactoring-2-Move Method</title>
      <link>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-Move-Method/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-Move-Method/</guid>
      <description>

&lt;p&gt;Move Method 重构实际上比较简单，一个简单的描述就是:
- 如果有一个方法在一个类里面出现的频率很高，但他不在这个类里面
- 那么Move Method就是把这个方法移动到出现频率高的这个类里面&lt;/p&gt;

&lt;h2 id=&#34;before-move-method:b7ce0c948eb782e6e3f0e0900e5f67ab&#34;&gt;Before Move Method&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BankAccountOrigin {

    private int accountAge;
    private int creditScore;
    private AccountInterestOrigin accountInterest;

    public double calculateInterestRate(){
        if(creditScore&amp;gt;800){
            return 0.02;
        }
        if(accountAge&amp;gt;10){
            return 0.03;
        }
        return 0.05;
    }
    ..... getter/setter
}

public class AccountInterestOrigin {
    private BankAccountOrigin ba;

    private double interestRate =ba.calculateInterestRate();
    private boolean introductorRate;

    public AccountInterestOrigin(BankAccountOrigin ba) {
        this.ba = ba;
    }
    public boolean isIntroductorRate() {
        return ba.calculateInterestRate()&amp;lt;0.05;
    }

    public void setIntroductorRate(boolean introductorRate) {
        this.introductorRate = introductorRate;
    }
}  

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;after-move-method:b7ce0c948eb782e6e3f0e0900e5f67ab&#34;&gt;After Move Method&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class AccountInterestRefactored {
    private BankAccountRefactored ba;

    private double interestRate =calculateInterestRate();
    private boolean introductorRate;

    public AccountInterestRefactored(BankAccountRefactored ba) {
        this.ba = ba;
    }

    public boolean isIntroductorRate() {
        return calculateInterestRate()&amp;lt;0.05;
    }

    private double calculateInterestRate(){
        if(ba.getCreditScore()&amp;gt;800){
            return 0.02;
        }
        if(ba.getAccountAge()&amp;gt;10){
            return 0.03;
        }
        return 0.05;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;关于有什么好处的思考:b7ce0c948eb782e6e3f0e0900e5f67ab&#34;&gt;关于有什么好处的思考&lt;/h2&gt;

&lt;p&gt;Move Method just move method to different location.
本身其实很难说有多少好处.经常整理自己抽屉的孩子，也不会把床搞得太乱.可能就是
这个道理。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Refactoring-3-Pull Up Method</title>
      <link>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-Pull-Up-Method/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-Pull-Up-Method/</guid>
      <description>

&lt;p&gt;Pull Up Method 顾名思义,就是把方法向上拉,向上拉是个什么意思呢?在面向
对象中向上就是向父类，或者接口拉,是不是很形象？&lt;/p&gt;

&lt;h2 id=&#34;pull-up-method实例:0780fcce19e5e47f35be7c7bb858ad26&#34;&gt;Pull Up Method实例&lt;/h2&gt;

&lt;p&gt;假设这样一个场景,目前有:
- 抽象类－Vehicle
- 继承了Vehicle的离散类－ Car
- 继承了Vehicle的离散类－ Motorcycle&lt;/p&gt;

&lt;p&gt;而turn方法目前只有在Car中有，那么我们把turn方法防盗Vehicle中
这样Motocyle也可以公用turn方法，这就是Pull Up Method.是不是很简单。。。。&lt;/p&gt;

&lt;p&gt;以下是代码实例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class Vehicle {

    public class Car extends Vehicle {
        public void turn(Direction d){
            System.out.println(&amp;quot;turing to &amp;quot;+d);
        }
    }

    public class Motorcycle extends Vehicle{
      public void turn(Direction d){
          System.out.println(&amp;quot;turing to &amp;quot;+d);
      }
    }

    public enum Direction {
        Left,Right
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用IDE refactor的pull up member 重构后再稍作修改后，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class VehicleRefactor {

    public void turn(Direction d) {
        System.out.println(&amp;quot;turing to &amp;quot; + d);
    }

    public class Car extends VehicleRefactor {
    }

    public class Motorcycle extends VehicleRefactor {
    }

    public enum Direction {
        Left, Right
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一个pull up method就完成了.是不是高大上的名次变成了现实的easy模式了。&lt;/p&gt;

&lt;p&gt;Dirty your hand,then you may know the truth.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Refactoring-4-Push Down Method and Pull Up and Posh Down Field</title>
      <link>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-PullUpField-PushDownField/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-PullUpField-PushDownField/</guid>
      <description>

&lt;p&gt;Push down method 和Pull Up method刚好相反.
有时会遇到公用的父类方法在某个子类中不需要了,如果这样的情况可以考虑将功用
方法放到具体的实现中&lt;/p&gt;

&lt;h2 id=&#34;push-down-method实例:497774c41e7eca3ac4463dc82da338d3&#34;&gt;Push Down Method实例&lt;/h2&gt;

&lt;p&gt;重构前：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class Animal {
    public void bark(){
        System.out.println(&amp;quot;testing&amp;quot;);   
    }
}

class Dog extends Animal{

}

class Cat extends Animal{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重构后:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public abstract class Animal {

}

class Dog extends Animal{
  public void bark(){
      System.out.println(&amp;quot;testing&amp;quot;);   
  }

}

class Cat extends Animal{

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pull-up-and-posh-down-field:497774c41e7eca3ac4463dc82da338d3&#34;&gt;Pull Up and Posh Down Field&lt;/h2&gt;

&lt;p&gt;Pull Up and Posh Down Field 表达了Pull up 和 Push Down method
基本上一样的意思，只不过一个是方法，一个是成员变量&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Refactoring-5-rename</title>
      <link>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-rename/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-rename/</guid>
      <description>&lt;p&gt;rename也是一个重构方式，对的，你没有看错，他确实是个重构的方法.
不要小看了命名，命名不是个简单活哦，他背后可能包含了历史，人文，幽默，
风格，立场。。。。。。。， 起个让大部分人都懂的名字可不是个容易活。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Refactoring-6-Replace Inheritance with Delegation</title>
      <link>http://simonpatrick.github.io/posts/refactoring/2015-10-26-replace-inheritance-with-delegation/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/refactoring/2015-10-26-replace-inheritance-with-delegation/</guid>
      <description>

&lt;p&gt;Replace Inheritance with Delegation, 这种重构方式主要是继承有时
看起来不是那么合理，同时继承可能让程序的扩展性不好，所以可以改用委托
或者组合的形式重构。&lt;/p&gt;

&lt;h2 id=&#34;代码实例:be4527962fd6026534a750a8b3b554a5&#34;&gt;代码实例&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Refactor前:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Sanitation {

    public String washHands(){
        return &amp;quot;Cleaned!&amp;quot;;
    }
}

class Child extends Sanitation{
    public static void main(String[] args) {
        System.out.println(new Child().washHands());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Refactor之后:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;把继承关系拿掉，才有委托的方式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class ChildRefactor{
    Sanitation s;
    public ChildRefactor() {
        s = new Sanitation();
    }

    public String washHands(){
        return s.washHands();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;好处的思考:be4527962fd6026534a750a8b3b554a5&#34;&gt;好处的思考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;逻辑上Sanitation(公共卫生)和Child没有那种继承关系,修改之后表达更加准确&lt;/li&gt;
&lt;li&gt;Child的washHand方法实际更加灵活了&lt;/li&gt;
&lt;li&gt;更加容易通过使用Dependency Injection注入&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Refactoring-7-Extract-Interface,Method,Sub Class,Supper Class</title>
      <link>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-Extract-Interface-Method/</link>
      <pubDate>Mon, 26 Oct 2015 10:31:11 +0800</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-Extract-Interface-Method/</guid>
      <description>

&lt;p&gt;Extract-Interface,Method,Sub Class,Supper Class&lt;/p&gt;

&lt;p&gt;以上重构的方式主要是通过提起接口,方法,为了让代码有更好的可读性,可测性.&lt;/p&gt;

&lt;h2 id=&#34;开始-实例代码:95695017f9058bd36998f67aa44f25e5&#34;&gt;开始:实例代码&lt;/h2&gt;

&lt;p&gt;以下是一个需要重构的实例代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Receipt {

    private List&amp;lt;Double&amp;gt; discounts= Lists.newArrayList();
    private List&amp;lt;Double&amp;gt; itemTotals=Lists.newArrayList();

    public double calculateGradTotal(){
        double subTotal =0;
        for (Double itemTotal : itemTotals) {
            subTotal+=itemTotal;
        }

        if(discounts.size()&amp;gt;0){
            for (Double discount : discounts) {
                subTotal-=discount;
            }
        }

        double tax=subTotal*0.065;
        subTotal+=tax;
        return subTotal;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;抽取方法:95695017f9058bd36998f67aa44f25e5&#34;&gt;抽取方法&lt;/h2&gt;

&lt;p&gt;阅读代码,根据计算方法的步骤,可以通过如下尝试抽取方法:
- calculateSubTotal
- calculateDiscounts
- calculateTax&lt;/p&gt;

&lt;p&gt;最后calculateGrandTotal 调用着三个方法. 由于实例代码比较简单,所以还看不出有多少优点.
但是如果想像calculateGrandTotal这个方法是很长的话，那么通过这种方式重构可以让计算calculateGrandTotal
的逻辑更加清晰.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public double calculateGrandTotal(){
        double subTotal=calculateSubTotal();
        subTotal=calculateDiscounts(subTotal);
        subTotal=calculateTax(subTotal);
        return subTotal;
    }

    public double calculateTax(double subTotal){
        double tax=subTotal*0.065;
        subTotal+=tax;
        return subTotal;
    }

    public double calculateDiscounts(double subTotal){
        if(discounts.size()&amp;gt;0){
            for (Double discount : discounts) {
                subTotal-=discount;
            }
        }

        return subTotal;
    }

    public double calculateSubTotal(){
        double subTotal=0;
        for (Double itemTotal : itemTotals) {
            subTotal+=itemTotal;
        }

        return subTotal;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;抽取接口:95695017f9058bd36998f67aa44f25e5&#34;&gt;抽取接口&lt;/h2&gt;

&lt;p&gt;接口的好处想来大家都不叫清楚，所以有时有不同的实现出现时，抽取一个接口定义来也是一个不错的重构
时间。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;假设ClassRegistration 如下:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class ClassRegistration {
  private double total;

  public void create(){
      System.out.println(&amp;quot;create&amp;quot;);
  }

  public void transfer(){
      System.out.println(&amp;quot;transfer&amp;quot;);
  }

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;有一个新的ClassRegistration，所以抽取接口&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface IClassRegistration {
    void create();
    double transfer();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后修改ClassRegistration 使他实现IClassRegistration&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端代码在增加一个实现之后实际上不需要修改了,或者只需要修改方法签名就可以&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RegistrationProcessor {
    public double processRegistration(IClassRegistration registration){
        registration.create();
        return registration.total();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;extract-subclass-supperclass:95695017f9058bd36998f67aa44f25e5&#34;&gt;Extract SubClass SupperClass&lt;/h2&gt;

&lt;p&gt;这两个实际上就是合并子类，或者分解类.将方法，属性放到更合适的位置。&lt;/p&gt;

&lt;h2 id=&#34;一些小结:95695017f9058bd36998f67aa44f25e5&#34;&gt;一些小结&lt;/h2&gt;

&lt;p&gt;通过移动方法，分解方法，合并子类，分离大类，个人认为实际上完成了一些目的:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将大方法分解到小方法，更好的维护&lt;/li&gt;
&lt;li&gt;分解不必要的依赖，可以通过新的实现来完成而不需要修改客户端代码&lt;/li&gt;
&lt;li&gt;大方法分解之后,方法负责的任务更加小，更加清楚&lt;/li&gt;
&lt;li&gt;小方法实际有更好的复用&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Refactoring-10-introduce method object, replace conditions with polymorphism</title>
      <link>http://simonpatrick.github.io/posts/refactoring/2015-11-3-refactoring-introduce-method-object-and-replace-conditions-with-poly/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/refactoring/2015-11-3-refactoring-introduce-method-object-and-replace-conditions-with-poly/</guid>
      <description>

&lt;h2 id=&#34;将方法参数转化为类:db9e886b8cc45cd7b8372d86addddf6f&#34;&gt;将方法参数转化为类&lt;/h2&gt;

&lt;p&gt;有时一个方法的传入参数太多，就需要考虑是否需要引入新的类来解决的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Registration {
    public void create(double amount,String name,
                       double credits){
        //do work
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重构后:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//instroduce new Class
public class RegistrationContext {

    double amount;
    String name;
    double credits;
}

//modify the method
public void createRefactored(RegistrationContext context){
    //do work
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;多态替代条件判断:db9e886b8cc45cd7b8372d86addddf6f&#34;&gt;多态替代条件判断&lt;/h2&gt;

&lt;p&gt;有时通过If&amp;hellip;Else来判断不同的类型进行不同的处理，代码可读性不是很强，通过多态来替代这些
条件判断，同时抽取方法后，代码就会更加的具有可读性.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class OrderProcessor {
    public double processOrder(Customer cu,List&amp;lt;Product&amp;gt; products){
        double orderTotal = products.parallelStream().mapToDouble(Product::getPrice).sum();
        if(cu instanceof Employee){
            orderTotal-=orderTotal*0.15;
        }

        if (cu instanceof NonEmployee){
            orderTotal-=orderTotal*0.10;
        }

        return orderTotal;
    }

}

public abstract class Customer {
}


public class Employee extends Customer {
}


public class NonEmployee extends Customer {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重构后:是不是代码更清楚了&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public abstract class Customer {
    abstract double tax();
}


public class Employee extends Customer {
    @Override
    double tax() {
        return 0.15;
    }
}


public class NonEmployee extends Customer {
    @Override
    double tax() {
        return 0.10;
    }
}



public double processOrderRefactor(Customer cu,List&amp;lt;Product&amp;gt; products){
    double orderTotal = products.parallelStream().mapToDouble(Product::getPrice).sum();

    orderTotal-=orderTotal*cu.tax();
    return orderTotal;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Refactoring-9-ArrowHead AntiPattern and Remove Double Negative</title>
      <link>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-arrowhead-and-double-negative/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/refactoring/2015-10-26-refactoring-arrowhead-and-double-negative/</guid>
      <description>

&lt;h2 id=&#34;arrowhead-antipattern:55dbaec2e142aec10a1ca1f3fee1917a&#34;&gt;Arrowhead AntiPattern&lt;/h2&gt;

&lt;p&gt;一下代码有一系列的if 判断，我们可以重新思考判断逻辑,合并一些逻辑判断
来让代码更可读:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean hasAccess(User user, Permission permission,
                        List&amp;lt;Permission&amp;gt; exemptions) {
      boolean hasPermission = false;
      if (user != null) {
          if (permission != null) {
              if (exemptions.Count() == 0) {
                  if (SecurityChecker.CheckPermission(user,permission) ||
                  exemptions.Contains(permission)) {
                      hasPermission = true;
                  }
              }
              return hasPermission;
          }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重构后:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;       if (user == null || permission == null)
           return false;
       if (exemptions.Contains(permission))
           return true;
       return SecurityChecker.CheckPermission(user, permission);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;remove-double-negative:55dbaec2e142aec10a1ca1f3fee1917a&#34;&gt;Remove Double Negative&lt;/h2&gt;

&lt;p&gt;remove double negative 实际上非常简单,代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void checkout(){
       if(!isNotNull()){
           System.out.println(&amp;quot;checking ....&amp;quot;);
       }
   }

   private boolean isNotNull(){
       return true;
   }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重构后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private boolean isNull(){
    return true;
}

public void checkoutRefactored(){
    if(isNull()){
        System.out.println(&amp;quot;checking ....&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改动虽小，是不是让你阅读代码更爽一点&amp;hellip;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>