<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Colored Hedwig</title>
    <link>http://simonpatrick.github.io/categories/java/</link>
    <description>Recent content in Java on Colored Hedwig</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 23 Dec 2015 23:28:22 +0000</lastBuildDate>
    <atom:link href="http://simonpatrick.github.io/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JAVA IDE 快捷键指南</title>
      <link>http://simonpatrick.github.io/posts/java/2015-12-23-ide_keyboards/</link>
      <pubDate>Wed, 23 Dec 2015 23:28:22 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/java/2015-12-23-ide_keyboards/</guid>
      <description>

&lt;p&gt;JAVA开发离不开IDE，IDE使用也离不开快捷键，一下是一些常用的快捷键.&lt;/p&gt;

&lt;h2 id=&#34;idea-快捷键:8ca75a9c5df1409fef35ca7bcd3ac3d4&#34;&gt;IDEA 快捷键&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;../../assets/images/pics/IDEA_shortkey_1.jpg&#34; alt=&#34;img&#34; /&gt;
&lt;img src=&#34;../../assets/images/pics/IDEA_shortkey_1.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;search-快捷键对比:8ca75a9c5df1409fef35ca7bcd3ac3d4&#34;&gt;Search 快捷键对比&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;../../assets/images/pics/search_shortkeys.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;code-navigation-快捷键对比:8ca75a9c5df1409fef35ca7bcd3ac3d4&#34;&gt;Code navigation 快捷键对比&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;../../assets/images/pics/code_nav.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;code-completion快捷键对比:8ca75a9c5df1409fef35ca7bcd3ac3d4&#34;&gt;Code completion快捷键对比&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;../../assets/images/pics/cc_shortkeys.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;windows-actions-快捷键对比:8ca75a9c5df1409fef35ca7bcd3ac3d4&#34;&gt;windows actions 快捷键对比&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;../../assets/images/pics/window_actions.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;refactor-快捷键对比:8ca75a9c5df1409fef35ca7bcd3ac3d4&#34;&gt;refactor 快捷键对比&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;../../assets/images/pics/refactoring_shotkeys.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;universary-access-快捷键对比:8ca75a9c5df1409fef35ca7bcd3ac3d4&#34;&gt;universary access 快捷键对比&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;../../assets/images/pics/universary_access_shortkeys.jpg&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Singleton 的不同写法</title>
      <link>http://simonpatrick.github.io/posts/java/2015-12-02-singleton/</link>
      <pubDate>Wed, 02 Dec 2015 12:42:18 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/java/2015-12-02-singleton/</guid>
      <description>

&lt;p&gt;Singleton是JAVA的一个非常常见的方式，不过不同写的方式会有不同的想法，下面就介绍一下这个模式&lt;/p&gt;

&lt;h2 id=&#34;singleton-懒汉式模式-线程不安全:32d3cbb27ae239adb8abd161a3e21442&#34;&gt;Singleton 懒汉式模式，线程不安全&lt;/h2&gt;

&lt;p&gt;一个基本的写法如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static LazySingleton instance;
  private LazySingleton(){}

  public static LazySingleton getInstance(){
      if(instance==null){
          instance=new LazySingleton();
      }

      return instance;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个的一个问题是线程不安全，就是当instance是null的时候，可能有两个线程同时满足，这样就是两个实例产生&lt;/p&gt;

&lt;p&gt;那么一个改进就是,加入synchronized&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static LazySingleton getInstance(){
        if(instance==null){
            synchronized (LazySingleton.class){
                instance=new LazySingleton();
            }
        }

        return instance;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来自网上的解释说这个也是有问题的:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。

给 instance 分配内存
调用 Singleton 的构造函数来初始化成员变量
将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）
但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么将instace定义为:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private volatile static Singleton instance; //声明成 volatile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化
读操作不会被重排序到内存屏障之前,从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序.&lt;/p&gt;

&lt;h2 id=&#34;singleton-饿汉式-static-final-field:32d3cbb27ae239adb8abd161a3e21442&#34;&gt;Singleton 饿汉式 static final field&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static final HungarySingleton instance = new HungarySingleton();

  private HungarySingleton() {
  }

  public static HungarySingleton getInstance() {
      return instance;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;内部静态类:32d3cbb27ae239adb8abd161a3e21442&#34;&gt;内部静态类&lt;/h2&gt;

&lt;p&gt;内部静态类实现的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public class SingletonHolderModel {
    private static class SingletonHolder {
        private static final SingletonHolderModel INSTANCE = new SingletonHolderModel();
    }

    private SingletonHolderModel() {
    }

    public static final SingletonHolderModel getInstance() {
        return SingletonHolderModel.SingletonHolder.INSTANCE;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;枚举:32d3cbb27ae239adb8abd161a3e21442&#34;&gt;枚举&lt;/h2&gt;

&lt;p&gt;我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public enum EasySingleton{
    INSTANCE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;source:32d3cbb27ae239adb8abd161a3e21442&#34;&gt;source&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://javarevisited.blogspot.sg/2014/05/double-checked-locking-on-singleton-in-java.html&#34;&gt;English&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Java 并发死锁实践－1</title>
      <link>http://simonpatrick.github.io/posts/java/2015-11-18-concurrence_dead_lock/</link>
      <pubDate>Wed, 18 Nov 2015 08:57:44 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/java/2015-11-18-concurrence_dead_lock/</guid>
      <description>

&lt;p&gt;写点学习Java 并发死锁实践的来记录一下学习JAVA 并发的经历.&lt;/p&gt;

&lt;p&gt;## 什么是JAVA的死锁(dead lock)
 死锁就是两个线程一直相互等待.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://incdn1.b0.upaiyun.com/2014/04/c9a8bba45f37b6dcfe1684867cb2a3e9-300x207.png&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;实例代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ThreadDeadlock {

    public static void main(String[] args) throws InterruptedException {
        Object obj1 = new Object();
        Object obj2 = new Object();
        Thread t1 = new Thread(new SyncThread(obj1, obj2), &amp;quot;t1&amp;quot;);
        Thread t2 = new Thread(new SyncThread(obj2, obj1), &amp;quot;t2&amp;quot;);
        t1.start();
        Thread.sleep(1000);
        t2.start();
    }
}

public class SyncThread implements Runnable{
    private Object obj1;
    private Object obj2;

    public SyncThread(Object o1, Object o2){
        this.obj1=o1;
        this.obj2=o2;
    }
    @Override
    public void run() {
        String name = Thread.currentThread().getName();
        System.out.println(name + &amp;quot; acquiring lock on object 1&amp;quot;+obj1);
        synchronized (obj1) {
         System.out.println(name + &amp;quot; acquired lock on object 1&amp;quot;+obj1);
         work();
         System.out.println(name + &amp;quot; acquiring lock on object 2&amp;quot;+obj2);
         synchronized (obj2) {
            System.out.println(name + &amp;quot; acquired lock on  object 2&amp;quot;+obj2);
            work();
        }
         System.out.println(name + &amp;quot; released lock on object 2&amp;quot;+obj2);
        }
        System.out.println(name + &amp;quot; released lock on object 1&amp;quot;+obj1);
        System.out.println(name + &amp;quot; finished execution.&amp;quot;);
    }

    private void work() {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;running result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;t1 acquiring lock on java.lang.Object@370cd189
t1 acquired lock on java.lang.Object@370cd189  -- lock object1
t2 acquiring lock on java.lang.Object@509afc84
t2 acquired lock on java.lang.Object@509afc84 -- lock object2
t1 acquiring lock on java.lang.Object@509afc84  -- try to lock object 2 waiting object 2 released
t2 acquiring lock on java.lang.Object@3165be7c -- try to lock object1  waiting object 1 released

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thread1 lock object1 waiting object2 released to release object1
Thread2 lock object2 waiting object1 released to release object2&lt;/p&gt;

&lt;p&gt;Thread1-&amp;gt;Thread2-&amp;gt;Thread1  所以死循环了，所以这就是死锁了。出现死锁后，线程就停止在那里一致等待了。
容器里面可能就有一只无法释放的线程堆积&lt;/p&gt;

&lt;p&gt;使用JVisualVM可以看到如下的ThreadDump:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Found one Java-level deadlock:
=============================
&amp;quot;t2&amp;quot;:
  waiting to lock monitor 0x00007ff1288332a8 (object 0x000000074001d9a8, a java.lang.Object),
  which is held by &amp;quot;t1&amp;quot;
&amp;quot;t1&amp;quot;:
  waiting to lock monitor 0x00007ff128830758 (object 0x000000074001d9b8, a java.lang.Object),
  which is held by &amp;quot;t2&amp;quot;

Java stack information for the threads listed above:
===================================================
&amp;quot;t2&amp;quot;:
	at com.hedwig.concurrence.deadlocksample.SyncThread.run(SyncThread.java:20)
	- waiting to lock &amp;lt;0x000000074001d9a8&amp;gt; (a java.lang.Object)
	- locked &amp;lt;0x000000074001d9b8&amp;gt; (a java.lang.Object)
	at java.lang.Thread.run(Thread.java:745)
&amp;quot;t1&amp;quot;:
	at com.hedwig.concurrence.deadlocksample.SyncThread.run(SyncThread.java:20)
	- waiting to lock &amp;lt;0x000000074001d9b8&amp;gt; (a java.lang.Object)
	- locked &amp;lt;0x000000074001d9a8&amp;gt; (a java.lang.Object)
	at java.lang.Thread.run(Thread.java:745)

Found 1 deadlock.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;避免死锁:6bc1e2bd5786f1a03041d1f0acc83029&#34;&gt;避免死锁&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;避免嵌套封锁, 在这个例子中可以之对一个object加锁&lt;/li&gt;
&lt;li&gt;只对有请求的进行封锁&lt;/li&gt;
&lt;li&gt;避免无限期的等待&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>tomcat-jmx-monitoring</title>
      <link>http://simonpatrick.github.io/posts/java/2015-11-15-tomcat-jmx-monitoring/</link>
      <pubDate>Sun, 15 Nov 2015 16:56:08 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/java/2015-11-15-tomcat-jmx-monitoring/</guid>
      <description>

&lt;p&gt;Tomcat JMX Monitoring&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Access Data Via JMX &amp;ldquo;MBeans&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Read/Write Bean Attributes&lt;/li&gt;
&lt;li&gt;Invoke Operations&lt;/li&gt;
&lt;li&gt;Receive Notifications&lt;/li&gt;
&lt;li&gt;JVM Exposes certain status&lt;/li&gt;
&lt;li&gt;Tomcat Exposes certain status&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;monitoring-jvm:b88f41b842b818e8339e1cf0329c3a7d&#34;&gt;Monitoring JVM&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Head status&lt;/li&gt;
&lt;li&gt;Total,Free Used Memory&lt;/li&gt;
&lt;li&gt;GC(Garbage Collection)&lt;/li&gt;
&lt;li&gt;GC Pause Time&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;monitoring-tomcat:b88f41b842b818e8339e1cf0329c3a7d&#34;&gt;Monitoring Tomcat&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Status of Connector&lt;/li&gt;
&lt;li&gt;Status of request-processor thread pool&lt;/li&gt;
&lt;li&gt;Status of data sources&lt;/li&gt;
&lt;li&gt;Request performance&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;jmx-tools:b88f41b842b818e8339e1cf0329c3a7d&#34;&gt;JMX Tools&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;jconsole (jdk)&lt;/li&gt;
&lt;li&gt;VisualVM (jdk)&lt;/li&gt;
&lt;li&gt;Most Profiles (Yourkit,etc.)&lt;/li&gt;
&lt;li&gt;Custom tools using javax.management&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;monitoring-your-application:b88f41b842b818e8339e1cf0329c3a7d&#34;&gt;Monitoring Your Application&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Monitor Application Processes&lt;/li&gt;
&lt;li&gt;Performance Metrics&lt;/li&gt;
&lt;li&gt;On-the-fly re-configuration&lt;/li&gt;
&lt;li&gt;Write An MBean

&lt;ul&gt;
&lt;li&gt;Create an Interface&lt;/li&gt;
&lt;li&gt;Create an Implementation&lt;/li&gt;
&lt;li&gt;Create an XML MBean descriptor&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Deploy package to Tomcat

&lt;ul&gt;
&lt;li&gt;Publish the MBean to the MBean server&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Query/invokes as neccessary&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;example-mbean:b88f41b842b818e8339e1cf0329c3a7d&#34;&gt;Example MBean&lt;/h2&gt;

&lt;p&gt;ttern
- Servlet Filter that captures total request processing time
  - Timestamp prior to request
  - Timestamp after request
  - Add the delta to a JMX-accessible counter: RequestStats&lt;/p&gt;

&lt;h2 id=&#34;automated-monitoring:b88f41b842b818e8339e1cf0329c3a7d&#34;&gt;Automated Monitoring&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Remote Access&lt;/li&gt;
&lt;li&gt;Large Scale&lt;/li&gt;
&lt;li&gt;Constant&lt;/li&gt;
&lt;li&gt;Tools:

&lt;ul&gt;
&lt;li&gt;Nagios&lt;/li&gt;
&lt;li&gt;Simple&lt;/li&gt;
&lt;li&gt;Flexible&lt;/li&gt;
&lt;li&gt;Well-deployed&lt;/li&gt;
&lt;li&gt;No-cost community version&lt;/li&gt;
&lt;li&gt;Plug-in architecture&lt;/li&gt;
&lt;li&gt;Freely-avaiable JMX Plug-in: check_JMX&lt;/li&gt;
&lt;li&gt;JMXProxyServlet&lt;/li&gt;
&lt;li&gt;Tracking Values over time&lt;/li&gt;
&lt;li&gt;Detecting OutOfMemory

&lt;ul&gt;
&lt;li&gt;Heap exhaustion&lt;/li&gt;
&lt;li&gt;PermGen exhaustion&lt;/li&gt;
&lt;li&gt;Hit thread limit&lt;/li&gt;
&lt;li&gt;Hit file descriptor limit&lt;/li&gt;
&lt;li&gt;Two types of Heap OutOfMemory&lt;/li&gt;
&lt;li&gt;One Thread generates lots of local reference&lt;/li&gt;
&lt;li&gt;All Threads collaborate to generate global reachable objects&lt;/li&gt;
&lt;li&gt;Former is recoverable,latter is not&lt;/li&gt;
&lt;li&gt;Memory Pool Threshold&lt;/li&gt;
&lt;li&gt;Polling using check_JMX&lt;/li&gt;
&lt;li&gt;Register a notification listener&lt;/li&gt;
&lt;li&gt;Use -XX:OnOutOfMememoryError on first OOME&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>