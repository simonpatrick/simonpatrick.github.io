<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Colored Hedwig</title>
    <link>http://simonpatrick.github.io/</link>
    <description>Recent content on Colored Hedwig</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 28 Feb 2016 14:57:44 +0000</lastBuildDate>
    <atom:link href="http://simonpatrick.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Python 面向对象，以及访问对象属性基础</title>
      <link>http://simonpatrick.github.io/posts/python/2016-02-28-python_oop_attributes/</link>
      <pubDate>Sun, 28 Feb 2016 14:57:44 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2016-02-28-python_oop_attributes/</guid>
      <description>

&lt;p&gt;在前面的Zabbix API调用中我们看到了python的&lt;code&gt;__getattr__&lt;/code&gt;的妙用，下面就探索一下这里面的道理,所以就聊聊python面向对象的基础知识.&lt;/p&gt;

&lt;h2 id=&#34;python-面向对象:b78d674c6bd0e41530240ac276bacbc6&#34;&gt;Python 面向对象&lt;/h2&gt;

&lt;p&gt;说到面向对象，就会说到类(class)，对象(object),那么什么是Class，Object呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Object：
Objects have states and behaviors. Example: A dog has states - color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class.&lt;/li&gt;
&lt;li&gt;Class:
A class can be defined as a template/blue print that describes the behaviors/states that object of its type support.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么综合起来，class就是用来描述一系列对象的一个模版，抽象出了共同的东西(class)，object就是具体的某种情况下的一个例子(instance)&lt;/p&gt;

&lt;p&gt;面向对象有如下基础概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Polymorphism&lt;/li&gt;
&lt;li&gt;Inheritance&lt;/li&gt;
&lt;li&gt;Encapsulation&lt;/li&gt;
&lt;li&gt;Abstraction&lt;/li&gt;
&lt;li&gt;Classes&lt;/li&gt;
&lt;li&gt;Objects&lt;/li&gt;
&lt;li&gt;Instance&lt;/li&gt;
&lt;li&gt;Method&lt;/li&gt;
&lt;li&gt;Message Parsing&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;python-class-and-object-的使用:b78d674c6bd0e41530240ac276bacbc6&#34;&gt;Python Class and Object 的使用&lt;/h2&gt;

&lt;p&gt;看下例：
- &lt;code&gt;class Dog&lt;/code&gt; 定义了一个类
- &lt;code&gt;__init__&lt;/code&gt; 构造这个类的方法，就是创建出一个Dog的对象是通过这个方法
- &lt;code&gt;name&lt;/code&gt;, 类的一个属性;&lt;code&gt;eat()&lt;/code&gt;,也可以看成是类的一个属性，实际上它是一个dog的一个行为(behavior)
- &lt;code&gt;dog = Dog()&lt;/code&gt; 是创建了一个Dog(class)的新的的对象(object), 按照我们上面说的，dog是类Dog(class)的一个实例(instance)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  class Dog:
    def __init__(self):
      self.name=&#39;dog&#39;

    def eat():
      print(&#39;eating......&#39;)

  dog = Dog()
  print(dog.name)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python-对象的创建:b78d674c6bd0e41530240ac276bacbc6&#34;&gt;Python 对象的创建&lt;/h2&gt;

&lt;p&gt;参考上例，分别来说明对象的创建，访问.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对象的访问&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;  dog = Dog()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dog() 实际上创建了一个Dog的实例(object),那么他具体是通过Dog类的那个东西去实现的呢？是&lt;code&gt;__init__&lt;/code&gt; 方法实现的，可以通过下面的例子还看看：&lt;/p&gt;

&lt;p&gt;我们修改代码，就class Dog 中的&lt;code&gt;__init__&lt;/code&gt;方法去掉，然后运行代码看看&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;AttributeError: &#39;Dog&#39; object has no attribute &#39;name&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是运行后的一个错误，也就是说&lt;code&gt;name&lt;/code&gt;没有被初始化，远来的例子中name是通过&lt;code&gt;__init__&lt;/code&gt; 方法去初始化的，这也说明了实例的创建是通过&lt;code&gt;__init__&lt;/code&gt;来创建的.&lt;/p&gt;

&lt;p&gt;把&lt;code&gt;__init__&lt;/code&gt; 的修改还原，同时修改原有代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def __init__(self):
    self.name=&#39;dog&#39;
    print(&#39;Dog is created .....&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行代码，发现Dog is created&amp;hellip;&amp;hellip;输出了，所以使用&lt;code&gt;__init__&lt;/code&gt;的猜测是正确的.
不过我们进一步做一个尝试，去掉&lt;code&gt;__init__&lt;/code&gt;的代码，我们发现其实dog实例也是可以创建的，那么要问，没有&lt;code&gt;__init__&lt;/code&gt;也可以创建呀，那么如果类都是通过&lt;code&gt;__init__&lt;/code&gt;实例化的，那么这个时候怎么实例化的呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(Dog.__base__)
print(Dog.__bases__)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用如上的代码可以知道Dog的base class是object，也就是使用object的&lt;code&gt;__init__&lt;/code&gt;来实例话自己的.
到这里就简单的介绍了一下Python实例的创建.&lt;/p&gt;

&lt;h2 id=&#34;python-类实例的创建-继承:b78d674c6bd0e41530240ac276bacbc6&#34;&gt;Python 类实例的创建－ 继承&lt;/h2&gt;

&lt;p&gt;面向对象就逃不过继承，下面看看在继承的情况下，如何创建对象的.
好，那么久先创建继承一个Dog的一个类： CrazyDog():&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class CrazyDog(Dog):

    def why_crazy(self):
        print(&#39;I am sick.......&#39;)

crazy_dog = CrazyDog()
crazy_dog.eat()
print(crazy_dog.name)
crazy_dog.why_crazy()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是一个创建了一个CrazyDog的类，继承了Dog，python中继承就是在类声明语句的()中加入需要继承的类.运行上面的程序，可以看到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Dog is created .....
eating .....
dog
I am sick.......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里就更加清楚的看到了子类在没有定义&lt;code&gt;__init__&lt;/code&gt;的情况下，去使用了父类的&lt;code&gt;__init__&lt;/code&gt;方法.接下来我们尝试用自己的&lt;code&gt;__init__&lt;/code&gt; 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class CrazyDog(Dog):
  def __init__(self):
      super().__init__()
  def why_crazy(self):
      print(&#39;I am sick.......&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意使用super的写法哦，他需要调用&lt;strong&gt;init&lt;/strong&gt;方法的哦.重写后实际上我们是显性调用了父类的&lt;code&gt;__init__&lt;/code&gt;方法，同时可以完成自己写自己的&lt;code&gt;__init__&lt;/code&gt;方法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class CrazyDog(Dog):
    def __init__(self):
        self.is_crazy=True

    def why_crazy(self):
        print(&#39;I am sick.......&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行，报错，name不存在,&lt;code&gt;AttributeError: &#39;CrazyDog&#39; object has no attribute &#39;name&#39;&lt;/code&gt;, 哦，远来要使用父类的属性，是需要显性初始化父类的,修改成如下代码，一切就OK了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class CrazyDog(Dog):
    def __init__(self):
        super().__init__()
        self.is_crazy=True

    def why_crazy(self):
        print(&#39;I am sick.......&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python-访问对象中的属性:b78d674c6bd0e41530240ac276bacbc6&#34;&gt;Python 访问对象中的属性&lt;/h2&gt;

&lt;p&gt;上面例子中其实已经有如何访问对象的属性或者方法了，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;crazy_dog = CrazyDog()
crazy_dog.eat()
print(crazy_dog.name)
crazy_dog.why_crazy()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些都非常容易理解，同时这里也可以看到，python的对象里面没有java的：&lt;code&gt;public,private,protected&lt;/code&gt;等定义来确定访问的范围.&lt;/p&gt;

&lt;h2 id=&#34;python-访问对象的属性-getattr-setattr:b78d674c6bd0e41530240ac276bacbc6&#34;&gt;Python 访问对象的属性： &lt;strong&gt;getattr&lt;/strong&gt;,&lt;strong&gt;setattr&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;继续再聊聊python的访问对象的属性，做个试验：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class CrazyDog(Dog):
    def __init__(self):
        super().__init__()
        self.is_crazy = True

    def why_crazy(self):
        print(&#39;I am sick.......&#39;)

    def __getattr__(self, item):
        print(&#39;getting attribute&#39;, item)
        return (item, &#39;getattr_created&#39;)
crazy_dog = CrazyDog()
crazy_dog.eat()
print(crazy_dog.name)
crazy_dog.why_crazy()
print(crazy_dog.name1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到如下结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Dog is created .....
eating .....
dog
I am sick.......
getting attribute name1
(&#39;name1&#39;, &#39;getattr_created&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子表明，如果访问没有定义变量名的时候，python是通过&lt;strong&gt;getattr&lt;/strong&gt;来访问的，未定义属性的赋值呢？&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class CrazyDog(Dog):
  def __init__(self):
      super().__init__()
      self.is_crazy = True

  def why_crazy(self):
      print(&#39;I am sick.......&#39;)

  def __getattr__(self, item):
      print(&#39;getting attribute&#39;, item)
      return (item, &#39;getattr_created&#39;)

  def __setattr__(self, key, value):
      print(&#39;using setattr set value&#39;)
      print(key, value)
      super().__setattr__(key, value)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;访问：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;crazy_dog = CrazyDog()
crazy_dog.eat()
print(crazy_dog.name)
crazy_dog.why_crazy()
crazy_dog.name2 = &#39;test_set_attr&#39;
print(crazy_dog.name1)
print(crazy_dog.name2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果&lt;code&gt;crazy_dog.name2&lt;/code&gt;是test_set_attr, 这个例子清楚的表明，没有定义的属性变量是通过&lt;code&gt;__setattr__&lt;/code&gt;去访问的，如果我们修改原有的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# super().__setattr__(key, value) 修改到如下的代码：
setattr(self,key,value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行，我们会发现递归深度不够的错误，所以这个地方我们需要使用&lt;code&gt;super().__setattr__(k,v)&lt;/code&gt;来处理, 那么为什么呢？
我自己推测是setattr(self,k,v)是使用了self的&lt;strong&gt;setattr&lt;/strong&gt;,那么很明显这个就是死循环了，因为他具体到了self这个实例，如果改为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;setattr(Dog,key,value)
setattr(CrazyDog,key,value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;都可以成功，相信这里面python语言再lookup method的时候有一套自己的方法.&lt;/p&gt;

&lt;p&gt;回顾一下这个&lt;strong&gt;getattr&lt;/strong&gt;,_setattr__ 两个方法，可以动态创建属性，这个机制会减少不少的代码量.和java比起来会减少很多的反射的代码.&lt;/p&gt;

&lt;p&gt;这块内容需要继续学习和挖掘！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simple Word Counter</title>
      <link>http://simonpatrick.github.io/posts/python/2016-02-28-simple_word_count/</link>
      <pubDate>Sun, 28 Feb 2016 10:41:15 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2016-02-28-simple_word_count/</guid>
      <description>

&lt;p&gt;有时测试的面试题中会考点编程的内容，比如统计字符串中的相同字符数量，具体题目如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;给定一个字符串，如MIssissippi&lt;/li&gt;
&lt;li&gt;计算字符串中每一个不同字符出现的数量&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;python-的解法:e6c4d79ca6914cdb5de91af5f8b312d6&#34;&gt;Python 的解法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;letter_count={}
for letter in &#39;MIssissippi&#39;:
  letter[letter]=letter_count.get(letter,0)+1
print(letter_count)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&#39;s&#39;: 4, &#39;M&#39;: 1, &#39;i&#39;: 3, &#39;I&#39;: 1, &#39;p&#39;: 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;java-的解法:e6c4d79ca6914cdb5de91af5f8b312d6&#34;&gt;Java 的解法&lt;/h2&gt;

&lt;p&gt;JAVA 8 中给Map加入了getOrDefault的方法，下面就分别介绍一下JAVA8之前和使用JAVA8的方法：&lt;/p&gt;

&lt;h3 id=&#34;java8-之前:e6c4d79ca6914cdb5de91af5f8b312d6&#34;&gt;JAVA8 之前：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Map&amp;lt;String,Integer&amp;gt; countCharacters(String source){
       char[] chars = source.toCharArray();
       Map&amp;lt;String,Integer&amp;gt; result = new HashMap&amp;lt;&amp;gt;();

       for (char aChar : chars) {
           Integer existing_counter = result.get(String.valueOf(aChar));
           int counter =  existing_counter==null?0:existing_counter;
           result.put(String.valueOf(aChar),counter+1);
       }
       return result;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;java8-解法:e6c4d79ca6914cdb5de91af5f8b312d6&#34;&gt;JAVA8 解法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public Map&amp;lt;String,Integer&amp;gt; countCharacters_JAVA8(String source){
    char[] chars = source.toCharArray();
    Map&amp;lt;String,Integer&amp;gt; result = new HashMap&amp;lt;&amp;gt;();
    for (char aChar : chars) {
        result.put(String.valueOf(aChar),result.getOrDefault(String.valueOf(aChar),0)+1);
    }
    return result;
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Python 访问Zabbix API</title>
      <link>http://simonpatrick.github.io/posts/python/2016-02-26-call_zabbix_api/</link>
      <pubDate>Fri, 26 Feb 2016 16:51:20 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2016-02-26-call_zabbix_api/</guid>
      <description>

&lt;h2 id=&#34;zabbix-api-访问:cf643a9d1d4340cbb976b94011be6da5&#34;&gt;Zabbix API 访问&lt;/h2&gt;

&lt;p&gt;准备使用Python来访问一下Zabbix，首先当然阅读一下Zabbix的&lt;a href=&#34;https://www.zabbix.com/documentation/2.4/&#34;&gt;API Manual&lt;/a&gt;,抛开什么json rpc这样的问题之外，zabbix的API的分类还是很工整的，所以看起来比较舒服，在一定了解了zabbix基础之后，基本上就可以上手来写了，网上查了一下，找个一个python zabbix的调用的一个客户段代码，感觉不错，就开始行动了。&lt;/p&gt;

&lt;h2 id=&#34;zabbix-api-客户端代码的实现:cf643a9d1d4340cbb976b94011be6da5&#34;&gt;Zabbix API 客户端代码的实现&lt;/h2&gt;

&lt;p&gt;Zabbix API的主要的两个参数其实是method，params，params基本上就可以看作一些可变的参数，其实就是一个json或者map， 对于method来说，一般就是 resource.action 这种方式，所以python客户端使用重写了一个&lt;strong&gt;getattr&lt;/strong&gt;来做,返回一个可以访问不同资源名称的客户端,具体的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ZabbixClient:
    &amp;quot;&amp;quot;&amp;quot;
    Generic Zabbix API Client
    - login
    - get auth
    &amp;quot;&amp;quot;&amp;quot;
    globale_header = {
        &amp;quot;Content-Type&amp;quot;: &amp;quot;application/json-rpc&amp;quot;
    }

    def __init__(self, session=None, timeout=None):
        self.user_name, self.default_user_name = &#39;1&#39;, &#39;1&#39;
        self.password, self.default_password = &#39;123456&#39;, &#39;123456&#39;
        self.zabbix_api_url = &#39;http://{0}/api_jsonrpc.php&#39;.format(&#39;abcd.http&#39;)
        if session:
            self.session = session
        else:
            self.session = requests.session()

        self.session.headers.update({
            &#39;Content-Type&#39;: &#39;application/json-rpc&#39;,
            &#39;User-Agent&#39;: &#39;python-zabbix-client&#39;,
            &#39;Cache-Control&#39;: &#39;no-cache&#39;
        })

        self.auth = &#39;&#39;
        self.id = 0
        self.timeout = timeout
        logger.info(&#39;JSON-RPC Server EndPoint: %s&#39;, self.zabbix_api_url)

    def login_in(self, user_name=None, password=None):
        &amp;quot;&amp;quot;&amp;quot;
        login with given user_name and password, if None, use default user
        :param user_name:
        :param password:
        :return: result,auth key
        &amp;quot;&amp;quot;&amp;quot;
        if user_name:
            self.user_name = user_name

        if password:
            self.password = password

        self.auth = self.user.login(user=self.user_name, password=self.password)

    def api_version(self):
        return self.apiinfo.version()

    # def confimport(self, format=&#39;&#39;, source=&#39;&#39;, rules=&#39;&#39;):
    #     &amp;quot;&amp;quot;&amp;quot;Alias for configuration.import because it clashes with
    #        Python&#39;s import reserved keyword&amp;quot;&amp;quot;&amp;quot;
    #
    #     return self.do_request(
    #         method=&amp;quot;configuration.import&amp;quot;,
    #         params={&amp;quot;format&amp;quot;: format, &amp;quot;source&amp;quot;: source, &amp;quot;rules&amp;quot;: rules}
    #     )[&#39;result&#39;]

    def do_request(self, method, params=None):
        request_json = {
            &#39;jsonrpc&#39;: &#39;2.0&#39;,
            &#39;method&#39;: method,
            &#39;params&#39;: params or {},
            &#39;id&#39;: self.id,
        }

        if method != &#39;apiinfo.version&#39; and self.auth:
            request_json[&#39;auth&#39;] = self.auth

        logger.debug(&amp;quot;sending: %s&amp;quot;, json.dumps(request_json, indent=4, separators=(&#39;,&#39;, &#39;:&#39;)))
        response = self.session.post(
            self.zabbix_api_url,
            data=json.dumps(request_json),
            timeout=self.timeout
        )
        logger.debug(&amp;quot;Response Code : %s&amp;quot;, str(response.status_code))

        response.raise_for_status()

        if not len(response.text):
            raise ZabbixAPIException(&amp;quot;没有返回值&amp;quot;)

        try:
            response_json = json.loads(response.text)
        except ValueError:
            raise ZabbixAPIException(&amp;quot;不能解析JSON %s&amp;quot; % response.text)

        logger.debug(&amp;quot;sending: %s&amp;quot;, json.dumps(request_json, indent=4, separators=(&#39;,&#39;, &#39;:&#39;)))

        self.id += 1

        if &#39;error&#39; in response_json:
            if &#39;data&#39; not in response_json[&#39;error&#39;]:
                response_json[&#39;error&#39;][&#39;data&#39;] = &#39;No Data&#39;
            msg = &amp;quot;Error {code}: {message},{data}&amp;quot;.format(
                code=response_json[&#39;error&#39;][&#39;code&#39;],
                message=response_json[&#39;error&#39;][&#39;message&#39;],
                data=response_json[&#39;error&#39;][&#39;data&#39;]
            )
            raise ZabbixAPIException(msg, response_json[&#39;error&#39;][&#39;code&#39;])

        return response_json

    def __getattr__(self, item):
        &amp;quot;&amp;quot;&amp;quot;
        auto create Zabbix API Client
        :param item:
        :return:
        &amp;quot;&amp;quot;&amp;quot;
        return ZabbixAPIObjectClass(item, self)


class ZabbixAPIObjectClass(object):
    def __init__(self, name, parent):
        self.name = name
        self.parent = parent

    def __getattr__(self, item):

        &amp;quot;&amp;quot;&amp;quot;
        dynamic create a method (get,create,update,delete)
        :param item:
        :return:
        &amp;quot;&amp;quot;&amp;quot;

        def fn(*args, **kwargs):
            if args and kwargs:
                raise TypeError(&#39;Found Both args and kwargs&#39;)

            return self.parent.do_request(&#39;{0}.{1}&#39;.format(self.name, item),
                                          args or kwargs)[&#39;result&#39;]

        return fn

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基本上一个文件就搞定了，不过这个基本上参考了网上的一个代码实现的，这里使用&lt;strong&gt;getattr&lt;/strong&gt;这种方式可以非常简洁的处理了这种请求非常类似的情况，这也是python的魅力吧.&lt;/p&gt;

&lt;h2 id=&#34;访问zabbix-api:cf643a9d1d4340cbb976b94011be6da5&#34;&gt;访问Zabbix API&lt;/h2&gt;

&lt;p&gt;访问API比较简单(如何参数不多的话，哈哈)，实例代码取Template的一些信息如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class TestZabbixTemplateClient(unittest.TestCase):

    def setUp(self):
        self.zapi = ZabbixClient()
        self.zapi.login_in()

    def test_get_template(self):
        templates = self.zapi.template.get()
        print(templates)

    def test_get_template(self):
        templates = self.zapi.template.get(
            filter={
                &amp;quot;host&amp;quot;: [&amp;quot;Template OS Linux&amp;quot;]
            })
        print(templates[0][&amp;quot;id&amp;quot;])

    def test_create_template(self):
        template = self.zapi.template.create()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;补充一句，就是其实可以看到：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ZabbixClient这个类没有定义template，可是他去可以使用？写了JAVA人是不是感觉有点惊喜的感觉&lt;/li&gt;
&lt;li&gt;template也没有create这个方法呀，他是怎么做到的？？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个例子很好的说明了使用&lt;code&gt;__getattr__&lt;/code&gt;可以做一些魔法的事情&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>zabbix 基础</title>
      <link>http://simonpatrick.github.io/posts/python/2016-02-26-zabbix_monitoring/</link>
      <pubDate>Fri, 26 Feb 2016 16:48:54 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2016-02-26-zabbix_monitoring/</guid>
      <description>

&lt;p&gt;抽空花了1个小时看了一下Zabbix的界面和简单的手册，了解了一下Zabbix的基础知识，下面是一个小小的记录,后面就写一些Python的脚本来直接调用Zabbix的API在进行一些自动化的操作.&lt;/p&gt;

&lt;h1 id=&#34;zabbix-基础:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Zabbix 基础&lt;/h1&gt;

&lt;p&gt;Zabbix 是一个开源的监控系统，由于需要帮助运维写一些调用ZABBIX API的代码，所以就开始了解一下ZABBIX的一些基本概念. 简单的看了一下Zabbix的一个手册，大致了解Zabbix监控的一些概念，以下是Zabbix中比较重要的概念或者可以认为一些抽象的实体资源:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Configuration&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HOST&lt;/li&gt;
&lt;li&gt;HOST GROUP&lt;/li&gt;
&lt;li&gt;Templates&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Monitor&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Application&lt;/li&gt;
&lt;li&gt;Items: keys&lt;/li&gt;
&lt;li&gt;Triggers&lt;/li&gt;
&lt;li&gt;Graphs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;configuration-host:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Configuration:HOST&lt;/h2&gt;

&lt;p&gt;HOST 就是Zabbix监控的对象，创建HOST可以通过一些预先定义好的模版来实现.
以Linux Group来说的话，HOST可能还有以下的一些属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Agent Interface&lt;/li&gt;
&lt;li&gt;SNMP Interface&lt;/li&gt;
&lt;li&gt;JMX Interface&lt;/li&gt;
&lt;li&gt;IPMI Interface&lt;/li&gt;
&lt;li&gt;Monitory proxy&lt;/li&gt;
&lt;li&gt;Status&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;configuration-host-group:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Configuration: HOST GROUP&lt;/h2&gt;

&lt;p&gt;创建HOST的同时可以创建一个HOST GROUP，HOST GROUP实际上就是不同的HOST组合起来成一组.&lt;/p&gt;

&lt;h2 id=&#34;configuration-templates:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Configuration: Templates&lt;/h2&gt;

&lt;p&gt;Templates 就是一些HOST的模版，相似的HOST可以通过模版继承，组合的方式创建&lt;/p&gt;

&lt;h2 id=&#34;monitor:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Monitor&lt;/h2&gt;

&lt;p&gt;从监控的层级来看，监控HOST的层级逻辑是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HOSTGROUP: HOST GROUP是可以认为不同HOST的容器&lt;/li&gt;
&lt;li&gt;HOST: 监控的实体,监控的实体实际上有不同的监控模版组合而成&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下的APPLICATION，ITEM,TRIGGER,Graph 其实都是继承了模版的：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;APPLICATION,可以认为是一组监控的内容&lt;/li&gt;
&lt;li&gt;ITEM: item就是监控的具体的一个数值,比如&lt;code&gt;cl Loaded Class Count&lt;/code&gt;他的key是&lt;code&gt;jmx[&amp;quot;java.lang:type=ClassLoading&amp;quot;,LoadedClassCount]&lt;/code&gt;
这个ITEM就是具体监控LoadedClass数目的一项，那么多个项目就可以组合成一个Application，ITEM 其实可以认为是采样数据的一个项&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个Template可以通过多个Application来组合而成，一个Application可以由Items来组合而成，一个HOST包含有多个监控的Template，一个HOST Group可以有多个HOST.&lt;/p&gt;

&lt;p&gt;关于TEMPLATE的继承关系是： HOST 继承HOST GROUP的TEMPLATE&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Graph： 图表&lt;/li&gt;
&lt;li&gt;Trigger： 触发器
这两个可以设置到模版级别的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;monitor-application:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Monitor: Application&lt;/h2&gt;

&lt;p&gt;Application 可以认为是监控的一个大的项目，里面可能包括了不同的采样项目(item)
create Application，可以参考一下API文档就可以&lt;/p&gt;

&lt;h2 id=&#34;monitor-item:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Monitor: Item&lt;/h2&gt;

&lt;p&gt;Item创建首先需要创建一个key(在创建KEY之前可以先创建一个TEMPLATE)，key 相当于需要监控什么，如何设置？
- 监控客户端设置, 在zabbix_agentd.conf中需要添加UserParameter&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;  grep -v &#39;#&#39; /etc/zabbix/zabbix_agentd.conf|grep -v &amp;quot;^$&amp;quot;
  export UserParameter=&amp;lt;key_name&amp;gt;,&amp;lt;shell_command&amp;gt; &amp;gt;&amp;gt;  &amp;lt;configure_file_location&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ITEM的设置，可以设置ITEM的类型，同时使用一些表达是来完成需要的采样内容的设置&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;graphs:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Graphs&lt;/h2&gt;

&lt;p&gt;graph 就是图标，那么很明显，一个graph有x,y 轴，x轴一般总是时间序列，另外一个轴对应不同的item（采样项目），同时又一些graph的类型选择，以及图表大小的设置&lt;/p&gt;

&lt;h2 id=&#34;triggers:2c1c486bd05ef403d4df037e1bc7ca7e&#34;&gt;Triggers&lt;/h2&gt;

&lt;p&gt;Trigger 就是一个触发器，对于单独的一个item来说，如果设置了一些阀值,那么如果超过这个阀值，那么就会报警了.&lt;/p&gt;

&lt;p&gt;这是Zabbix的一些基本概念，其他还有如：
- Action, 遇到问题进行的操作
- Screens: 多个Graph就组合成一个Screen
- Slideshow: 多个Screen可以轮播
- Map: 网络路径图
- Discovery Rule: 发现安装Zabbix Agent的机器的规则
- 其他：如一些各种interface的设置，大致有个了结，可能在后续中会使用&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Mobile 性能测试关键点</title>
      <link>http://simonpatrick.github.io/posts/performance/2016-02-22-mobile_perf_testing/</link>
      <pubDate>Mon, 22 Feb 2016 09:40:07 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/performance/2016-02-22-mobile_perf_testing/</guid>
      <description>

&lt;h1 id=&#34;移动端性能测试的一些关键点:2202e7560ce8ebc9e9a46ee2cc007ed5&#34;&gt;移动端性能测试的一些关键点&lt;/h1&gt;

&lt;p&gt;阅读了一些人的PPT，再这里记录一些移动端性能测试的一些关键点，每个关键点会在后续润色，细化.&lt;/p&gt;

&lt;h2 id=&#34;移动端性能测试的方方面面:2202e7560ce8ebc9e9a46ee2cc007ed5&#34;&gt;移动端性能测试的方方面面&lt;/h2&gt;

&lt;h3 id=&#34;android:2202e7560ce8ebc9e9a46ee2cc007ed5&#34;&gt;Android&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Monkey&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Memory Usage:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/system/build.prop
dalvik.vm.heapstartsize=8m
# 堆分配的初始大小
dalvik.vm.heapgrowthlimit=64m
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;adb shell procrank&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DDMS&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;adb shell top&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动性能(首次，多次)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;流量&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;应用占用量，cachesize，datasize，codesize&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;电量&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CPU: active, idel&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;memory leak, hprof, ddms dump hprof&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GPU 过度绘制
1.蓝色1x过度绘制
2.绿色2x过度绘制
3.淡红色3x过度绘制
4.红色超过4x过度绘制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;gfxinfo&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;systrace&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;traceview&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;tracer for OpenGL ES&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ios:2202e7560ce8ebc9e9a46ee2cc007ed5&#34;&gt;IOS&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;instruments&lt;/li&gt;
&lt;li&gt;api&lt;/li&gt;
&lt;li&gt;business flow/scenario&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;performance-baseline:2202e7560ce8ebc9e9a46ee2cc007ed5&#34;&gt;Performance Baseline&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;comparison&lt;/li&gt;
&lt;li&gt;颗粒度&lt;/li&gt;
&lt;li&gt;Business flow&lt;/li&gt;
&lt;li&gt;Automation supporting&lt;/li&gt;
&lt;li&gt;poor network condition&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;security:2202e7560ce8ebc9e9a46ee2cc007ed5&#34;&gt;Security&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;混淆&lt;/li&gt;
&lt;li&gt;加固&lt;/li&gt;
&lt;li&gt;权限&lt;/li&gt;
&lt;li&gt;本地数据库安全&lt;/li&gt;
&lt;li&gt;ContentProvider共享&lt;/li&gt;
&lt;li&gt;Activity注入风险&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tools:2202e7560ce8ebc9e9a46ee2cc007ed5&#34;&gt;Tools&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Fiddler&lt;/li&gt;
&lt;li&gt;Charles&lt;/li&gt;
&lt;li&gt;Burpsuites&lt;/li&gt;
&lt;li&gt;Anyproxy&lt;/li&gt;
&lt;li&gt;lint&lt;/li&gt;
&lt;li&gt;findbugs&lt;/li&gt;
&lt;li&gt;PMD&lt;/li&gt;
&lt;li&gt;oclint&lt;/li&gt;
&lt;li&gt;scan-build&lt;/li&gt;
&lt;li&gt;pro-guarded&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>JMETER 分布式测试</title>
      <link>http://simonpatrick.github.io/posts/performance/2016-02-22-jmeter_distribution_testing/</link>
      <pubDate>Mon, 22 Feb 2016 09:33:59 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/performance/2016-02-22-jmeter_distribution_testing/</guid>
      <description>

&lt;h1 id=&#34;jmeter-distribution-testing:47e09e012cb1af401091cc1822be73b2&#34;&gt;JMETER DISTRIBUTION TESTING&lt;/h1&gt;

&lt;p&gt;JMETER有时进行压力测试时，生成压力的机器性能不够，不能产生足够的压力，不过JMETER可以使用多个系统进行JMETER的压力测试，来解决这个问题. 使用多系统测试时需要注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;关闭防火墙&lt;/li&gt;
&lt;li&gt;client in the same subnet&lt;/li&gt;
&lt;li&gt;服务器在同一个字网&lt;/li&gt;
&lt;li&gt;Jmeter可以访问服务器&lt;/li&gt;
&lt;li&gt;JMeter是同一版本的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;jmeter-distribution-setting:47e09e012cb1af401091cc1822be73b2&#34;&gt;JMETER Distribution Setting&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Master Setup
config remote address:
jmeter.properties: remote_host=ip1,ip2,ip3&amp;hellip;..&lt;/li&gt;
&lt;li&gt;salve setup

&lt;ul&gt;
&lt;li&gt;running jmeter-server.bat/.sh 文件&lt;/li&gt;
&lt;li&gt;modify jmeter-server file to change the rmiregistry location&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;start TESTING&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;additional-resources:47e09e012cb1af401091cc1822be73b2&#34;&gt;Additional Resources&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://wiki.apache.org/jmeter/JMeterFAQ#How_to_do_remote_testing_the_.27proper_way.27.3F&#34;&gt;JMETER FAQ&lt;/a&gt; &lt;a href=&#34;http://jmeter.apache.org/usermanual/remote-test.html&#34;&gt;REMOTE-TEST&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>python yaml 使用介绍</title>
      <link>http://simonpatrick.github.io/posts/python/2016-02-13-python-yaml/</link>
      <pubDate>Sat, 13 Feb 2016 18:38:43 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/python/2016-02-13-python-yaml/</guid>
      <description>

&lt;h1 id=&#34;python-yaml-应用:3b71fa4aa27b698fdcd613a231439d69&#34;&gt;Python YAML 应用&lt;/h1&gt;

&lt;p&gt;YAML由于其可读性，越来越多的地方用它来做配置文件了来代替XML文件.下面就是用来介绍如何使用PYTHON来进行YAML的操作.
读取yaml或者写yaml，主要是用的是两个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;load 读&lt;/li&gt;
&lt;li&gt;dump 写&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;read-yaml-to-list:3b71fa4aa27b698fdcd613a231439d69&#34;&gt;Read YAML to List&lt;/h2&gt;

&lt;p&gt;以下是读YAML 内容到python的list&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PYTHON&#34;&gt;import yaml
def load_list():
    content = &amp;quot;&amp;quot;&amp;quot;
        - config
        - domain
        - repository
    &amp;quot;&amp;quot;&amp;quot;
    return yaml.load(content)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;read-yaml-to-dict:3b71fa4aa27b698fdcd613a231439d69&#34;&gt;Read YAML TO DICT&lt;/h2&gt;

&lt;p&gt;load yaml to dict or a nest dict:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import yaml

def load_dict():
  content = &amp;quot;&amp;quot;&amp;quot;
      hello1: test
      hello2: test2
  &amp;quot;&amp;quot;&amp;quot;
  return yaml.load(content)


def load_all_dict():
  contents = &amp;quot;&amp;quot;&amp;quot;
    hero:
      hp: 34
      sp: 8
      level: 4
    orc:
      hp: 12
      sp: 0
      level: 2
  &amp;quot;&amp;quot;&amp;quot;
  return yaml.load(contents)

print(load_dict())
print(load_all_dict())
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;read-yaml-auto-type-conversation:3b71fa4aa27b698fdcd613a231439d69&#34;&gt;Read YAML: auto type conversation&lt;/h2&gt;

&lt;p&gt;yaml 对于格式要求比较严格的，： 后面注意加空格，同时python的原始类型通过load函数可以自动转化的.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import yaml

def load_with_type():
    contents = &amp;quot;&amp;quot;&amp;quot;
        none: [~,null]
        bool: [true,false,on,off]
        int: 42
        float: 3.1415
        list: [test1,test2,test3]
        dict: {name: simon,sp: 5}
    &amp;quot;&amp;quot;&amp;quot;

    return yaml.load(contents)

print(load_with_type())

## result:
{&#39;dict&#39;: {&#39;name&#39;: &#39;simon&#39;, &#39;sp&#39;: 5}, &#39;none&#39;: [None, None], &#39;int&#39;: 42, &#39;bool&#39;: [True, False, True, False], &#39;list&#39;: [&#39;test1&#39;, &#39;test2&#39;, &#39;test3&#39;], &#39;float&#39;: 3.1415}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dump-yaml-write-contents-to-a-yml-file:3b71fa4aa27b698fdcd613a231439d69&#34;&gt;Dump YAML: write contents to a yml file&lt;/h2&gt;

&lt;p&gt;使用dump函数直接可以将dict 内容写入到yml文件，这里有两个参数：
- default_flow_style: 设为false之后就&lt;code&gt;first_name: simon&lt;/code&gt; 这种格式了
- default_style: 设为‘“’, first_name 就会加上“”&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def dump_file():
    contents = {
        &#39;name&#39;: &#39;test&#39;,
        &#39;first_name&#39;: &#39;simon&#39;,
        &#39;last_name&#39;: &#39;kevin&#39;
    }
    # return yaml.dump(contents)
    with open(&#39;document.yaml&#39;, &#39;w&#39;) as f:
        return yaml.dump(contents, f, default_flow_style=False, default_style=&#39;&amp;quot;&#39;)

# file result:
&amp;quot;first_name&amp;quot;: &amp;quot;simon&amp;quot;
&amp;quot;last_name&amp;quot;: &amp;quot;kevin&amp;quot;
&amp;quot;name&amp;quot;: &amp;quot;test&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;复杂一点的yaml格式:3b71fa4aa27b698fdcd613a231439d69&#34;&gt;复杂一点的YAML格式&lt;/h2&gt;

&lt;p&gt;下面一个yaml文件表示了一个JAVA maven项目里面主要的一些目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;      main:
        - config
        - domain
        - repository
        - service
        - rest:
          - controller
          - dto
          - exception
        - exceptions
        - utils
      resources:
        - config
      test:
        - config
        - domain
        - repository
        - service
        - rest:
          - controller
          - dto
          - exception
        - exceptions
        - utils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读取此文件的python代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
def read_yaml_file():
    with open(&#39;springboot-folders.yml&#39;, &#39;r&#39;) as f:
        result = yaml.load(f)

    return result
folders = read_yaml_file()
print(folders[&#39;main&#39;])
print(folders[&#39;test&#39;])
print(folders[&#39;resources&#39;])

# result:
[&#39;config&#39;, &#39;domain&#39;, &#39;repository&#39;, &#39;service&#39;, {&#39;rest&#39;: [&#39;controller&#39;, &#39;dto&#39;, &#39;exception&#39;]}, &#39;exceptions&#39;, &#39;utils&#39;]
[&#39;config&#39;, &#39;domain&#39;, &#39;repository&#39;, &#39;service&#39;, {&#39;rest&#39;: [&#39;controller&#39;, &#39;dto&#39;, &#39;exception&#39;]}, &#39;exceptions&#39;, &#39;utils&#39;]
[&#39;config&#39;]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上已经非常清楚的表示了如何读取yml文件了， 至此简单的yml的使用介绍就到此为止. 更加详细的介绍请参考：
&lt;a href=&#34;http://pyyaml.org/wiki/PyYAMLDocumentation&#34;&gt;python yaml&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>01-微服务框架－Springboot/Flask,Hello World</title>
      <link>http://simonpatrick.github.io/posts/microservice/2016-02-01-microservice-try/</link>
      <pubDate>Mon, 01 Feb 2016 23:57:29 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/microservice/2016-02-01-microservice-try/</guid>
      <description>

&lt;p&gt;现在有很多的微服务框架，这里试用一下Java Springboot和Python的Flask.
本文分别试用SpringBoot和Flask完成了一个简单的Hello World服务来展示如何使用Springboot和Flask构建
一个简单的服务. 同时用AB进行了一个简单的压力测试。&lt;/p&gt;

&lt;h2 id=&#34;springboot-hello-world-web-application:f52343a2a46f58140124ef653bf998a9&#34;&gt;SpringBoot Hello World Web Application&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Create a SpringBoot Application entry point&lt;/li&gt;
&lt;li&gt;add Beans into springboot startup life cycle&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  利用command-line runner的这个特性，再配合依赖注入，可以在应用程序启动时后首先引入一些依赖bean，例如data source、rpc服务或者其他模块等等，这些对象的初始化可以放在run方法中。不过，需要注意的是，在run方法中执行初始化动作的时候一旦遇到任何异常，都会使得应用程序停止运行，因此最好利用try/catch语句处理可能遇到的异常。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;create HelloWorld Service&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;all-codes-for-the-simple-hello-world-service:f52343a2a46f58140124ef653bf998a9&#34;&gt;All Codes for the simple &lt;strong&gt;&lt;em&gt;hello world&lt;/em&gt;&lt;/strong&gt; Service&lt;/h2&gt;

&lt;p&gt;以下代码的一些说明：
- Web 应用的执行入口： main方法，里面的SpringApplication.run
- StartupRunner 可以在SpringBoot Application启动过程中一些事情
- RestController注解表示了这个类是个Rest 风格的Controller&lt;/p&gt;

&lt;p&gt;pom.xml 中的唯一依赖，请指定版本或者parent指定为        &lt;code&gt;&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@SpringBootApplication
@RestController
public class HelloWorldEndPoint {

    public static void main(String[] args) {
        SpringApplication.run(HelloWorldEndPoint.class,args);
    }

    public static class StartupRunner implements CommandLineRunner{
        protected final Logger logger = LoggerFactory.getLogger(StartupRunner.class);

        @Override
        public void run(String... strings) throws Exception {
            logger.info(&amp;quot;startup command is running ........&amp;quot;);
        }
    }
    //inject into spring start lifecycle
    @Bean
    @Order(value = 1)
    public StartupRunner runner(){
        return new StartupRunner();
    }

    @Bean
    @Order(value = 2)
    public StartupRunner runner2(){
        return new StartupRunner(){

            @Override
            public void run(String... strings) throws Exception {
                System.out.println(&amp;quot;start up 2 command is running......&amp;quot;);
            }
        };
    }

    @RequestMapping(&amp;quot;/&amp;quot;)
    @ResponseBody
    public String home(){
        return &amp;quot;hello world!&amp;quot;;
    }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;启动springboot-应用:f52343a2a46f58140124ef653bf998a9&#34;&gt;启动springboot 应用&lt;/h2&gt;

&lt;p&gt;运行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mvn spring-boot:run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以启动springboot的应用，默认是tomcat的容器，如果又需要修改tomcat的配置，再后面文章中说明。&lt;/p&gt;

&lt;h2 id=&#34;curl测试:f52343a2a46f58140124ef653bf998a9&#34;&gt;curl测试&lt;/h2&gt;

&lt;p&gt;使用curl简单测试一下，可以访问，是不是简单呀&amp;hellip;&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ curl http://localhost:8080/                                                            
hello world!%
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;helloworld-in-flask:f52343a2a46f58140124ef653bf998a9&#34;&gt;HelloWorld In Flask&lt;/h1&gt;

&lt;p&gt;构建Flask的Micro Service 系列的第一篇，Hello World Service&lt;/p&gt;

&lt;h2 id=&#34;flask-环境设置:f52343a2a46f58140124ef653bf998a9&#34;&gt;Flask 环境设置&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;安装Python3&lt;/li&gt;
&lt;li&gt;创建干净的web 应用的python3 环境,python3 可以不用virtualevn，直接用一下命令就可以了
&lt;code&gt;sh
python3 -m venv &amp;lt;your_application_name&amp;gt;
&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;flask-helloworld-service:f52343a2a46f58140124ef653bf998a9&#34;&gt;Flask HelloWorld Service&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from flask import Flask

hello_world=Flask(__name__)

@hello_world.rooter(&#39;/&#39;)
def hello_world():
    return &#39;hello world!&#39;


if __name__ == &#39;__main__&#39;:
    hello_world.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;运行flask-helloworld-service:f52343a2a46f58140124ef653bf998a9&#34;&gt;运行Flask HelloWorld Service&lt;/h2&gt;

&lt;p&gt;直接运行次文件就可以了&lt;/p&gt;

&lt;h2 id=&#34;使用ab-进行简单的性能测试:f52343a2a46f58140124ef653bf998a9&#34;&gt;使用AB 进行简单的性能测试&lt;/h2&gt;

&lt;p&gt;AB的脚本如下： -n 表述总数，－c 表述并发&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# $1 is a parameter for java or python to record different performance result
ab -n 3000 -c 30 http://127.0.0.1:8080/ &amp;gt; $1-3K-30C.txt
ab -n 6000 -c 50 http://127.0.0.1:8080/ &amp;gt; $1-6K-50C.txt
ab -n 12000 -c 100 http://127.0.0.1:8080/ &amp;gt; $1-12K-100C.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后的结果：&lt;/p&gt;

&lt;p&gt;30 Currents:&lt;/p&gt;

&lt;p&gt;SpringBoot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Concurrency Level:      30
Time taken for tests:   5.828 seconds
Complete requests:      3000
Failed requests:        0
Total transferred:      522000 bytes
HTML transferred:       36000 bytes
Requests per second:    514.71 [#/sec] (mean)
Time per request:       58.285 [ms] (mean)
Time per request:       1.943 [ms] (mean, across all concurrent requests)
Transfer rate:          87.46 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0   42 443.0      2    5092
Processing:     0    4   2.7      4      19
Waiting:        0    3   2.4      3      19
Total:          1   46 442.9      6    5100

Percentage of the requests served within a certain time (ms)
  50%      6
  66%      7
  75%      8
  80%      9
  90%     12
  95%     15
  98%     19
  99%     30
 100%   5100 (longest request)


 Concurrency Level:      50
Time taken for tests:   1.161 seconds
Complete requests:      6000
Failed requests:        0
Total transferred:      1044000 bytes
HTML transferred:       72000 bytes
Requests per second:    5166.09 [#/sec] (mean)
Time per request:       9.678 [ms] (mean)
Time per request:       0.194 [ms] (mean, across all concurrent requests)
Transfer rate:          877.83 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    3   2.4      3      18
Processing:     1    6   3.3      6      32
Waiting:        0    5   3.0      4      30
Total:          3   10   4.0      8      33

Percentage of the requests served within a certain time (ms)
  50%      8
  66%      9
  75%     11
  80%     11
  90%     14
  95%     17
  98%     24
  99%     27
 100%     33 (longest request)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Flask: Current Level 100的时候没有timeout出现，不过springboot有而不能完成实验.
在100个并发前，SpringBoot比Flask略快，但是不知道什么原因springboot在100个并发的时候不能完成，这个会在后续使用中再做分析&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Concurrency Level:      30
Time taken for tests:   2.598 seconds
Complete requests:      3000
Failed requests:        0
Total transferred:      498000 bytes
HTML transferred:       36000 bytes
Requests per second:    1154.77 [#/sec] (mean)
Time per request:       25.979 [ms] (mean)
Time per request:       0.866 [ms] (mean, across all concurrent requests)
Transfer rate:          187.20 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.1      0       3
Processing:     1   26   5.8     24      67
Waiting:        1   26   5.7     24      67
Total:          2   26   5.8     24      67

Percentage of the requests served within a certain time (ms)
  50%     24
  66%     25
  75%     25
  80%     27
  90%     32
  95%     37
  98%     45
  99%     52
 100%     67 (longest request)

 Concurrency Level:      50
 Time taken for tests:   4.731 seconds
 Complete requests:      6000
 Failed requests:        0
 Total transferred:      996000 bytes
 HTML transferred:       72000 bytes
 Requests per second:    1268.30 [#/sec] (mean)
 Time per request:       39.423 [ms] (mean)
 Time per request:       0.788 [ms] (mean, across all concurrent requests)
 Transfer rate:          205.60 [Kbytes/sec] received

 Connection Times (ms)
               min  mean[+/-sd] median   max
 Connect:        0    0   0.2      0       3
 Processing:     2   39   3.2     39      50
 Waiting:        2   39   3.2     39      50
 Total:          5   39   3.1     39      50

 Percentage of the requests served within a certain time (ms)
   50%     39
   66%     40
   75%     40
   80%     40
   90%     41
   95%     46
   98%     48
   99%     49
  100%     50 (longest request)

  Concurrency Level:      100
  Time taken for tests:   32.135 seconds
  Complete requests:      12000
  Failed requests:        0
  Total transferred:      1992000 bytes
  HTML transferred:       144000 bytes
  Requests per second:    373.43 [#/sec] (mean)
  Time per request:       267.790 [ms] (mean)
  Time per request:       2.678 [ms] (mean, across all concurrent requests)
  Transfer rate:          60.54 [Kbytes/sec] received

  Connection Times (ms)
                min  mean[+/-sd] median   max
  Connect:        0  167 1816.4      0   20069
  Processing:     1  101 149.1     74    1559
  Waiting:        1  100 149.0     74    1559
  Total:          1  267 1816.7     75   20070

  Percentage of the requests served within a certain time (ms)
    50%     75
    66%     79
    75%     81
    80%     86
    90%     98
    95%    180
    98%    720
    99%   1543
   100%  20070 (longest request)

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>assertions</title>
      <link>http://simonpatrick.github.io/posts/automation/2016-02-01-assertions/</link>
      <pubDate>Mon, 01 Feb 2016 23:48:35 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/automation/2016-02-01-assertions/</guid>
      <description>

&lt;p&gt;由于一直都在进行测试的工作，所以会关注Assertion的工具，发现两个不错的Assertion 第三方包，准备在实践中使用. 这两个分别是：
- Google Truth(&lt;a href=&#34;http://google.github.io/truth/usage/&#34;&gt;http://google.github.io/truth/usage/&lt;/a&gt;)
- &lt;a href=&#34;http://joel-costigliola.github.io/assertj/&#34;&gt;assertj&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个里面有很多自己想实现的比较的功能。一下是一些简单的试用的代码。&lt;/p&gt;

&lt;h2 id=&#34;google-truth:62f3f66b6738b4dd3d6ba85aeb557c94&#34;&gt;Google Truth&lt;/h2&gt;

&lt;p&gt;基础的验证：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
  public void test_basic_truth(){
       Set&amp;lt;String&amp;gt; foo = Sets.newHashSet();
       assertThat(foo).isEmpty();
       assertThat(foo).isNotNull();
       assertThat(5).isEqualTo(5L);
       assertThat(5L).isEqualTo(5);
       assert_().that(50).isEqualTo(50);
       assertThat(&amp;quot;test&amp;quot;).isEqualTo(&amp;quot;test&amp;quot;);
       assertThat(&amp;quot;test&amp;quot;).contains(&amp;quot;te&amp;quot;);
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Collections/Maps的验证:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
   public void test_basic_truth_maps_collections(){
       Set&amp;lt;String&amp;gt; foo = Sets.newHashSet();
       assertThat(foo).isEmpty();
       assertThat(foo).isNotNull();
       foo.add(&amp;quot;test&amp;quot;);
       foo.add(&amp;quot;test1&amp;quot;);
       foo.add(&amp;quot;test2&amp;quot;);
       assertThat(foo).contains(&amp;quot;test&amp;quot;);
       assertThat(foo).containsAllOf(&amp;quot;test&amp;quot;, &amp;quot;test1&amp;quot;);
       assertThat(foo).containsExactly(&amp;quot;test2&amp;quot;, &amp;quot;test&amp;quot;, &amp;quot;test1&amp;quot;);
       assertThat(foo).containsNoneOf(&amp;quot;test889&amp;quot;, &amp;quot;test10&amp;quot;);

       Map&amp;lt;String,String&amp;gt; maps = Maps.newHashMap();
       maps.put(&amp;quot;test&amp;quot;, &amp;quot;test1&amp;quot;);
       maps.put(&amp;quot;test1&amp;quot;, &amp;quot;test2&amp;quot;);
       maps.put(&amp;quot;test2&amp;quot;, &amp;quot;test3&amp;quot;);
       assertThat(maps).containsKey(&amp;quot;test1&amp;quot;);
       assertThat(maps).containsEntry(&amp;quot;test1&amp;quot;, &amp;quot;test2&amp;quot;);
       assertThat(maps).doesNotContainEntry(&amp;quot;test0&amp;quot;, &amp;quot;test0&amp;quot;);
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;assertj:62f3f66b6738b4dd3d6ba85aeb557c94&#34;&gt;assertj&lt;/h2&gt;

&lt;p&gt;基础的验证：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
 public void test_contains(){
     assertThat(&amp;quot;aaa&amp;quot;).contains(&amp;quot;aa&amp;quot;);
 }

 @Test
 public void test_list_contains(){
     List&amp;lt;String&amp;gt; result = Lists.newArrayList(&amp;quot;abcd&amp;quot;,&amp;quot;ddds&amp;quot;,&amp;quot;ttest&amp;quot;);
     assertThat(result).contains(&amp;quot;ddds&amp;quot;);
 }
 @Test
 public void test_list_contains_onlyonce(){
     List&amp;lt;String&amp;gt; result = Lists.newArrayList(&amp;quot;abcd&amp;quot;,&amp;quot;ddds&amp;quot;,&amp;quot;ttest&amp;quot;);
     assertThat(result).containsOnlyOnce(&amp;quot;ddds&amp;quot;);
 }

 @Test
     public void test_list_contains_ELementOf(){
     List&amp;lt;String&amp;gt; result = Lists.newArrayList(&amp;quot;abcd&amp;quot;,&amp;quot;ddds&amp;quot;,&amp;quot;ttest&amp;quot;);
     assertThat(result).containsExactlyElementsOf(Lists.newArrayList(&amp;quot;abcd&amp;quot;, &amp;quot;ddds&amp;quot;, &amp;quot;ttest&amp;quot;));
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Guava 的验证：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
   public void MultiMap_assertions() {
       Multimap&amp;lt;String, String&amp;gt; actual = ArrayListMultimap.create();
       actual.putAll(&amp;quot;Lakers&amp;quot;, newArrayList(&amp;quot;Kobe Bryant&amp;quot;, &amp;quot;Magic Johnson&amp;quot;, &amp;quot;Kareem Abdul Jabbar&amp;quot;));
       actual.putAll(&amp;quot;Spurs&amp;quot;, newArrayList(&amp;quot;Tony Parker&amp;quot;, &amp;quot;Tim Duncan&amp;quot;, &amp;quot;Manu Ginobili&amp;quot;));

       assertThat(actual).containsKeys(&amp;quot;Lakers&amp;quot;, &amp;quot;Spurs&amp;quot;);
       assertThat(actual).contains(entry(&amp;quot;Lakers&amp;quot;, &amp;quot;Kobe Bryant&amp;quot;),
               entry(&amp;quot;Spurs&amp;quot;, &amp;quot;Tim Duncan&amp;quot;));
   }

   @Test
   public void multiple_set_assertions() {
       Multimap&amp;lt;String, String&amp;gt; listMultimap = ArrayListMultimap.create();
       listMultimap.putAll(&amp;quot;Spurs&amp;quot;, newArrayList(&amp;quot;Tony Parker&amp;quot;, &amp;quot;Tim Duncan&amp;quot;, &amp;quot;Manu Ginobili&amp;quot;));
       listMultimap.putAll(&amp;quot;Bulls&amp;quot;, newArrayList(&amp;quot;Michael Jordan&amp;quot;, &amp;quot;Scottie Pippen&amp;quot;, &amp;quot;Derrick Rose&amp;quot;));

       Multimap&amp;lt;String, String&amp;gt; setMultimap = TreeMultimap.create();
       setMultimap.putAll(&amp;quot;Spurs&amp;quot;, newHashSet(&amp;quot;Tony Parker&amp;quot;, &amp;quot;Tim Duncan&amp;quot;, &amp;quot;Manu Ginobili&amp;quot;));
       setMultimap.putAll(&amp;quot;Bulls&amp;quot;, newHashSet(&amp;quot;Michael Jordan&amp;quot;, &amp;quot;Scottie Pippen&amp;quot;, &amp;quot;Derrick Rose&amp;quot;));

// assertion will pass as listMultimap and setMultimap have the same content
       assertThat(listMultimap).hasSameEntriesAs(setMultimap);

// this assertion FAILS even though both multimaps have the same content
       assertThat(listMultimap).isEqualTo(setMultimap);
   }


   @Test
   public void range_assertions() {
       Range&amp;lt;Integer&amp;gt; range = Range.closed(10, 12);
       assertThat(range).isNotEmpty()
               .contains(10, 11, 12)
               .hasClosedLowerBound()
               .hasLowerEndpointEqualTo(10)
               .hasUpperEndpointEqualTo(12);
   }

   @Test
   public void table_assertion() {
       // Table assertions
       Table&amp;lt;Integer, String, String&amp;gt; bestMovies = HashBasedTable.create();

       bestMovies.put(1970, &amp;quot;Palme d&#39;Or&amp;quot;, &amp;quot;M.A.S.H&amp;quot;);
       bestMovies.put(1994, &amp;quot;Palme d&#39;Or&amp;quot;, &amp;quot;Pulp Fiction&amp;quot;);
       bestMovies.put(2008, &amp;quot;Palme d&#39;Or&amp;quot;, &amp;quot;Entre les murs&amp;quot;);
       bestMovies.put(2000, &amp;quot;Best picture Oscar&amp;quot;, &amp;quot;American Beauty&amp;quot;);
       bestMovies.put(2011, &amp;quot;Goldene Bär&amp;quot;, &amp;quot;A Separation&amp;quot;);

       assertThat(bestMovies).hasRowCount(5).hasColumnCount(3).hasSize(5)
               .containsValues(&amp;quot;American Beauty&amp;quot;, &amp;quot;A Separation&amp;quot;, &amp;quot;Pulp Fiction&amp;quot;)
               .containsCell(1994, &amp;quot;Palme d&#39;Or&amp;quot;, &amp;quot;Pulp Fiction&amp;quot;)
               .containsColumns(&amp;quot;Palme d&#39;Or&amp;quot;, &amp;quot;Best picture Oscar&amp;quot;, &amp;quot;Goldene Bär&amp;quot;)
               .containsRows(1970, 1994, 2000, 2008, 2011);
   }

   @Test
   public void test_opotions() {
       // Optional assertions
       Optional&amp;lt;String&amp;gt; optional = Optional.of(&amp;quot;Test&amp;quot;);
       assertThat(optional).isPresent().contains(&amp;quot;Test&amp;quot;);

       Optional&amp;lt;Long&amp;gt; optionalNum = Optional.of(12L);
       assertThat(optionalNum).extractingValue()
               .isInstanceOf(Long.class)
               .isEqualTo(12L);

        optional = Optional.of(&amp;quot;Bill&amp;quot;);
// extractingCharSequence allows to chain String specific assertion
       assertThat(optional).extractingCharSequence()
               .startsWith(&amp;quot;Bi&amp;quot;);

   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;日期的验证：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Test
   public void date_before(){

       DateTime dateTime = new DateTime();
       DateTime firstDateTime = new DateTime();
       firstDateTime.plus(10000L);
       assertThat(dateTime).isBefore(firstDateTime);
       assertThat(dateTime).isAfter(&amp;quot;2004-12-13T21:39:45.618-08:00&amp;quot;);
       assertThat(dateTime).isAfter(&amp;quot;2004-12-13T21:39:00&amp;quot;);
       assertThat(dateTime).isAfter(&amp;quot;2004-12-13T21:39:00&amp;quot;);

   }

   @Test
   public void joda_datetime_compare(){

       DateTime utcTime = new DateTime(2013, 6, 10, 0, 0, DateTimeZone.UTC);
       DateTime cestTime = new DateTime(2013, 6, 10, 2, 0, DateTimeZone.forID(&amp;quot;Europe/Berlin&amp;quot;));

       assertThat(utcTime).as(&amp;quot;in UTC time&amp;quot;).isEqualTo(cestTime);
   }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>WEB 开发的几个重点</title>
      <link>http://simonpatrick.github.io/posts/automation/2016-01-27-web-dev/</link>
      <pubDate>Wed, 27 Jan 2016 22:47:28 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/automation/2016-01-27-web-dev/</guid>
      <description>&lt;p&gt;再试用了Web 开发的框架之后，归纳一下大致的一个基础Web 开发需要的那些元素:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;URL Router，如何定义URL的访问&lt;/li&gt;
&lt;li&gt;Request Handler/Response Handler， HTTP请求/返回的处理

&lt;ul&gt;
&lt;li&gt;如果组织这些Request Handler/Response Handler&lt;/li&gt;
&lt;li&gt;如何定义全局/局部的URL拦截器&lt;/li&gt;
&lt;li&gt;如何处理特殊的HTTP Header&lt;/li&gt;
&lt;li&gt;如何处理Session/Cookie&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Database Access Layer/ORM， 数据操作CRUD

&lt;ul&gt;
&lt;li&gt;如何CRUD&lt;/li&gt;
&lt;li&gt;如何进行分页，排序，filterByCriteria&amp;hellip;..等数据库的常见操作&lt;/li&gt;
&lt;li&gt;如何管理事务&lt;/li&gt;
&lt;li&gt;如何定义，初始化数据库表&lt;/li&gt;
&lt;li&gt;如何组织不同的数据库操作成不同的业务动作&lt;/li&gt;
&lt;li&gt;详细，复杂的ORM操作可以不用太在意&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Template Render,模版渲染

&lt;ul&gt;
&lt;li&gt;不同模版的试用&lt;/li&gt;
&lt;li&gt;静态资源的访问&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;单元测试

&lt;ul&gt;
&lt;li&gt;断言，EXCEPTION检查&lt;/li&gt;
&lt;li&gt;Mock&lt;/li&gt;
&lt;li&gt;数据，内存数据库的使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Web Application部署

&lt;ul&gt;
&lt;li&gt;不同环境的配置管理&lt;/li&gt;
&lt;li&gt;不同语言的打包工具，如MAVEN，GRADLE&lt;/li&gt;
&lt;li&gt;不同的构建工具,GULP&lt;/li&gt;
&lt;li&gt;不同的服务器，NGINX，TOMCAT，JBOSS&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ptyhon design pattern: chain of responsibility</title>
      <link>http://simonpatrick.github.io/posts/designpattern/2016-01-11-ptyhon-design-pattern-chain/</link>
      <pubDate>Mon, 11 Jan 2016 23:35:45 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/designpattern/2016-01-11-ptyhon-design-pattern-chain/</guid>
      <description>&lt;p&gt;python 的责任链模式.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;方法链：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上代码吧： 其实就死return 了一个self，java里面可能是this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
class Person(object):
    def __init__(self, name, action):
        self.name = name
        self.action = action

    def do_action(self):
        print(self.name, self.action.name, end=&#39; &#39;)
        return self.action


class Action(object):
    def __init__(self, name):
        self.name = name

    def amount(self, val):
        print(val, end=&#39; &#39;)
        return self

    def stop(self):
        print(&#39;then stop&#39;)


if __name__ == &#39;__main__&#39;:
    move = Action(&#39;move&#39;)
    person=Person(&#39;Jack&#39;,move)
    person.do_action().amount(&#39;5m&#39;).stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;责任链:&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是一个责任链的模式，一个handler叠加，下例中：
ConcreteHandler1-&amp;gt;ConcreteHandler3-&amp;gt;ConcreteHandler2-&amp;gt;DefaultHandler,
那么如果第一个request满足了ConcreteHandler1的条件，就结束了，如果没有怎尝试ConcreteHandler3，知道满足了就退出.
这样就把一大批if else 转化成不同的handler了.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Handler:
    def __init__(self, successor):
        self._successor = successor;

    def handle(self, request):
        i = self._handle(request)
        if not i:
            self._successor.handle(request)

    def _handle(self, request):
        raise NotImplementedError(&#39;Must provide implementation in subclass.&#39;)


class ConcreteHandler1(Handler):
    def _handle(self, request):
        if 0 &amp;lt; request &amp;lt;= 10:
            print(&#39;request {} handled in handler 1&#39;.format(request))
            return True


class ConcreteHandler2(Handler):
    def _handle(self, request):
        if 10 &amp;lt; request &amp;lt;= 20:
            print(&#39;request {} handled in handler 2&#39;.format(request))
            return True


class ConcreteHandler3(Handler):
    def _handle(self, request):
        if 20 &amp;lt; request &amp;lt;= 30:
            print(&#39;request {} handled in handler 3&#39;.format(request))
            return True


class DefaultHandler(Handler):
    def _handle(self, request):
        print(&#39;end of chain, no handler for {}&#39;.format(request))
        return True


class Client:
    def __init__(self):
        self.handler = ConcreteHandler1(ConcreteHandler3(ConcreteHandler2(DefaultHandler(None))))

    def delegate(self, requests):
        for request in requests:
            self.handler.handle(request)


if __name__ == &amp;quot;__main__&amp;quot;:
    client = Client()
    requests = [2, 5, 14, 22, 18, 3, 35, 27, 20]
    client.delegate(requests)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>python-borg-design-pattern</title>
      <link>http://simonpatrick.github.io/posts/designpattern/2016-01-11-python-design-pattern-borg/</link>
      <pubDate>Mon, 11 Jan 2016 23:05:26 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/designpattern/2016-01-11-python-design-pattern-borg/</guid>
      <description>

&lt;p&gt;Python Design Pattern: Borg&lt;/p&gt;

&lt;h2 id=&#34;borg:55f4fe74eecacc8a05b13cb7793b0531&#34;&gt;Borg&lt;/h2&gt;

&lt;p&gt;Borg 模式实际上就是一个类的多个实例共享一个相同的状态.
简单的代码实现如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;__author__ = &#39;patrick&#39;


class Borg:
    _share_state = {}

    def __init__(self):
        self.__dict__ = self._share_state
        self.state = &#39;Init&#39;

    def __str__(self):
        return self.state


class YourBorg(Borg):
    pass


if __name__ == &#39;__main__&#39;:
    rm1 = Borg()
    rm2 = Borg()
    rm1.state = &#39;Idle&#39;
    rm2.state = &#39;Running&#39;

    print(&#39;rm1: {0}&#39;.format(rm1))
    print(&#39;rm2: {0}&#39;.format(rm2))

    rm2.state = &#39;Zombie&#39;

    print(&#39;rm1: {0}&#39;.format(rm1))
    print(&#39;rm2: {0}&#39;.format(rm2))

    print(&#39;rm1 id: {0}&#39;.format(id(rm1)))
    print(&#39;rm2 id: {0}&#39;.format(id(rm2)))

    rm3 = YourBorg()

    print(&#39;rm1: {0}&#39;.format(rm1))
    print(&#39;rm2: {0}&#39;.format(rm2))
    print(&#39;rm3: {0}&#39;.format(rm3))

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>为什么自动化，如何自动化</title>
      <link>http://simonpatrick.github.io/posts/automation/2016-01-10-why_how_automation/</link>
      <pubDate>Sun, 10 Jan 2016 19:14:11 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/automation/2016-01-10-why_how_automation/</guid>
      <description>

&lt;p&gt;在做一件事情之前，问一句为什么是必要的.做自动化测试之前也是一样，不管如何总是要有一个理由的吗，哪怕是所有的人都做，我也要做这样的理由. 以下说说我觉得要做自动化的理由.&lt;/p&gt;

&lt;h2 id=&#34;为什么自动化-why-automation-testing:f49549e192c371c0accd826ee3754a08&#34;&gt;为什么自动化(Why Automation Testing)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;为什么自动化,对于测试的而言的理由 VS 实际情况&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;自动化可以减少重复的回归测试(实际中的我问题:那么回归测试在你日常的测试中比例是多少)&lt;/li&gt;
&lt;li&gt;自动化测试可以提高自己的编码能力(这个原因无论如何是成立的)&lt;/li&gt;
&lt;li&gt;自动化测试可以进行更快的迭代（实际中的问题：自动化测试的不稳定可能不一定起到预想的作用）&lt;/li&gt;
&lt;li&gt;自动化测试可以做更多的回归测试内容，减少风险(实际中的问题：不稳定的测试可能不一定能够达到目的)&lt;/li&gt;
&lt;li&gt;不同的测试环境可以运行相同的测试(实际的问题： 可能没有那么多的环境，一般情况下都有测试环境，集成环境，预发布环境，生产环境，其实不是没个公司都需要这样做的&amp;hellip;&amp;hellip;)&lt;/li&gt;
&lt;li&gt;对于被测系统有更深刻的理解.由于需要编写代码，有时需要更深刻的理解内部的代码实现原理(实际中因人而异&amp;hellip;&amp;hellip;)&lt;/li&gt;
&lt;li&gt;自动化测试不仅仅包括进行测试，还包括一切去提高交付产品效率质量的东西，对于测试而言提出了新要求(always true if QA really does this)&lt;/li&gt;
&lt;li&gt;功能测试的业务知识可能在这家公司有用，到别家就没用了，但是会写代码可以积累自己(always true)&lt;/li&gt;
&lt;li&gt;无论是性能测试和安全测试都需要代码能力，通过自动化代码的编写可以更好的了解，掌握性能测试或者安全测试(实际情况：不是没个人都对编码感兴趣的)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;为什么自动化,对于公司的而言的理由 VS 实际情况&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测试用例通过代码的方式积累下来，自动化测试可能不会立竿见影，但是他有复利的效果（实际情况：遗留的测试代码真的有用吗？）&lt;/li&gt;
&lt;li&gt;系统如果重构那么通过自动化测试来完成很大一部分的功能测试（实际情况：遗留的测试代码真的有用吗？）&lt;/li&gt;
&lt;li&gt;减少回归测试少测漏测风险（实际情况：遗留的测试代码真的有用吗？）&lt;/li&gt;
&lt;li&gt;可以加速交付(交付流水线中不同的环境可以通过代码来跑，实际情况：遗留的测试代码真的有用吗？)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;how-to-automation-test:f49549e192c371c0accd826ee3754a08&#34;&gt;How to automation test&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;有统一的框架(框架一定要有IoC／DI的概念使用)&lt;/li&gt;
&lt;li&gt;有扩展性的框架&lt;/li&gt;
&lt;li&gt;方便实用，可以代码生产的工具链&lt;/li&gt;
&lt;li&gt;安装自动化测试金字塔（单元，接口，UI）方式&lt;/li&gt;
&lt;li&gt;千万不要使用自动化测试的anti-pattern&lt;/li&gt;
&lt;li&gt;有规划，一步一步优化，不要贪多&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>sql injection, sql 注入</title>
      <link>http://simonpatrick.github.io/posts/testing/2016-01-05-sql-injection/</link>
      <pubDate>Tue, 05 Jan 2016 23:37:49 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/testing/2016-01-05-sql-injection/</guid>
      <description>

&lt;p&gt;SQL注入的问题由来以久,主要是针对于一些系统时通过拼接SQL的方式来处理程序.以下是关于JAVA WEB的一些SQL注入的介绍.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.owasp.org/index.php/Preventing_SQL_Injection_in_Java&#34;&gt;来源OWASP&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;什么是sql注入:e945a6473403ff74947fb6df2db9baa1&#34;&gt;什么是SQL注入&lt;/h2&gt;

&lt;p&gt;SQL injection vulnerabilities allow an attacker to inject (or execute) SQL commands within an application.
大意就是攻击者可以通过修改页面请求来执行sql达到自己的目的，比如拉数据，或者恶意的修改数据等等.&lt;/p&gt;

&lt;h2 id=&#34;sql-注入例子:e945a6473403ff74947fb6df2db9baa1&#34;&gt;SQL 注入例子&lt;/h2&gt;

&lt;p&gt;一下例子是有SQL注入漏洞的一段程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt;conn = pool.getConnection( );
String sql = &amp;quot;select * from user where username=&#39;&amp;quot; + username +&amp;quot;&#39; and password=&#39;&amp;quot; + password + &amp;quot;&#39;&amp;quot;;
stmt = conn.createStatement();
rs = stmt.executeQuery(sql);
if (rs.next()) {
loggedIn = true;
	out.println(&amp;quot;Successfully logged in&amp;quot;);
} else {
	out.println(&amp;quot;Username and/or password not recognized&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于SQL是拼接的，所有如果用户直接食用username，或者password中 使用了如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt;admin&#39; OR &#39;1&#39;=&#39;1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后执行的SQL就是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt;select * from user where username=&#39;admin&#39; OR &#39;1&#39;=&#39;1&#39; and password=&#39; &#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明显，这样就会把所有的用户信息拿到了&lt;/p&gt;

&lt;h2 id=&#34;防范措施-defense-strategy:e945a6473403ff74947fb6df2db9baa1&#34;&gt;防范措施 Defense Strategy&lt;/h2&gt;

&lt;p&gt;prevent SQL injection:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All queries should be parametrized.&lt;/li&gt;
&lt;li&gt;All dynamic data should be explicitly bound to parametrized queries.&lt;/li&gt;
&lt;li&gt;String concatenation should never be used to create dynamic SQL.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;parameterized-queries-stored-procedures:e945a6473403ff74947fb6df2db9baa1&#34;&gt;Parameterized Queries／Stored Procedures&lt;/h2&gt;

&lt;p&gt;参数化SQL，使用prepareStatement&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JAVA&#34;&gt;String selectStatement = &amp;quot;SELECT * FROM User WHERE userId = ? &amp;quot;;
PreparedStatement prepStmt = con.prepareStatement(selectStatement);
prepStmt.setString(1, userId);
ResultSet rs = prepStmt.executeQuery();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;存储过程基本上能够防止SQL注入&lt;/p&gt;

&lt;h2 id=&#34;hibernate-mybatis:e945a6473403ff74947fb6df2db9baa1&#34;&gt;Hibernate/MyBatis&lt;/h2&gt;

&lt;p&gt;不要以为使用了ORM框架就没有SQL注入，其实不当使用也会有的.比如:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hibernate native SQL&lt;/li&gt;
&lt;li&gt;order by 没法使用绑定变量&lt;/li&gt;
&lt;li&gt;动态表名也无法使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;owasp-java-project:e945a6473403ff74947fb6df2db9baa1&#34;&gt;OWASP JAVA Project&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.owasp.org/index.php/Category:OWASP_Java_Project#tab=Project_and_OWASP_Resources&#34;&gt;OWASP_Java_Project&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>静态代码检查</title>
      <link>http://simonpatrick.github.io/posts/testing/2016-01-05-static-code-analysis/</link>
      <pubDate>Tue, 05 Jan 2016 23:00:55 +0000</pubDate>
      
      <guid>http://simonpatrick.github.io/posts/testing/2016-01-05-static-code-analysis/</guid>
      <description>

&lt;p&gt;静态代码检查有利于提高代码质量，同时也可以快速的发现一些问题. 常用的静态代码检查有一下几种，
checkstyle，pmd，findbugs. 刚好公司需要做一个mybatis SQL注入的检查，所以收集了一下关于这三个工具使用的介绍&lt;/p&gt;

&lt;h2 id=&#34;checkstyle-pmd-findbugs-的是使用介绍:b3b756f5fbe7139e7e22096adcb7bf61&#34;&gt;checkstyle,PMD,findbugs 的是使用介绍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;checkstyle&lt;/strong&gt; enforce coding conventions and standards in code, missing/improper javadoc, naming conventions, placement of braces and parentheses, whitespace, line length, etc&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PMD&lt;/strong&gt; detect bad practices,PMD 支持不同语言，如JAVA，Ruby，XML等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;findbugs&lt;/strong&gt; really find potential bugs,比如NPE，equals，hashcode等的用法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考文章：
&lt;a href=&#34;http://tirthalpatel.blogspot.com/2014/01/static-code-analyzers-checkstyle-pmd-findbugs.html&#34;&gt;checkstyle vs pmd vs findbugs&lt;/a&gt;
&lt;a href=&#34;http://www.sonarqube.org/sonar-to-identify-security-vulnerabilities/&#34;&gt;sonar security&lt;/a&gt;
&lt;a href=&#34;https://www.sparkred.com/blog/open-source-java-static-code-analyzers/&#34;&gt;checkstyle vs pmd vs findbugs 2&lt;/a&gt;
&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-findbug1/&#34;&gt;findbugs&lt;/a&gt;
&lt;a href=&#34;http://findbugs.sourceforge.net/bugDescriptions.html?cm_mc_uid=11877464828514517953725&amp;amp;cm_mc_sid_50200000=1452010453&#34;&gt;findbugs bugs&lt;/a&gt;
&lt;a href=&#34;http://findbugs.sourceforge.net/index.html&#34;&gt;find bugs home page&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>