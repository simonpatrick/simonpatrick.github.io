  <!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.15" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <link rel='stylesheet' href='http://fonts.useso.com/css?family=Open+Sans|Marcellus+SC'>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/css/tomorrow-night-eighties.css">
    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/custom.css">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="http://testless.github.io//index.xml">

    
    <title>Colored Hedwig: less is more</title>
    <meta property='og:title' content="Colored Hedwig: less is more">
    <meta property="og:type" content="website">
    

    <meta property="og:url" content="http://testless.github.io/">
    
    

  </head>

  <body>

    <header class="site">
      <div class="title"><a href="http://testless.github.io/">Colored Hedwig: less is more</a></div>
    </header>

    <div class="container site">

  <div class="row">
    <div class="col-sm-9">
      <div class="articles">
        <div class="row">
          
          <div class="col-sm-6">
            <article class="li">
  <a href="http://testless.github.io/posts/refactoring/2015-10-26-refactoring-PullUpField-PushDownField/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/5.jpg);"></div>
    <div class="detail">
      <time>Mon, Oct 26, 2015</time>
      <h2 class="title">Refactoring-4-Push Down Method and Pull Up and Posh Down Field</h2>
      <div class="summary">Push down method 和Pull Up method刚好相反. 有时会遇到公用的父类方法在某个子类中不需要了,如果这样的情况可以考虑将功用 方法放到具体的实现中 Push Down Method实例 重构前： public abstract class Animal { public void bark(){ System.out.println(&quot;testing&quot;); } } class Dog extends Animal{ } class Cat extends Animal{ } 重构后: public abstract class Animal { } class Dog extends Animal{ public void bark(){ System.out.println(&quot;testing&quot;); } } class Cat extends Animal{ } Pull Up and Posh Down Field Pull Up and Posh Down Field 表达了Pull up 和</div>
    </div>
  </a>
</article>

          </div>
          
          <div class="col-sm-6">
            <article class="li">
  <a href="http://testless.github.io/posts/refactoring/2015-10-26-refactoring-rename/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/7.jpg);"></div>
    <div class="detail">
      <time>Mon, Oct 26, 2015</time>
      <h2 class="title">Refactoring-5-rename</h2>
      <div class="summary">rename也是一个重构方式，对的，你没有看错，他确实是个重构的方法. 不要小看了命名，命名不是个简单活哦，他背后可能包含了历史，人文，幽默， 风格，立场。。。。。。。， 起个让大部分人都懂的名字可不是个容易活。</div>
    </div>
  </a>
</article>

          </div>
          
          <div class="col-sm-6">
            <article class="li">
  <a href="http://testless.github.io/posts/refactoring/2015-10-26-replace-inheritance-with-delegation/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/10.jpg);"></div>
    <div class="detail">
      <time>Mon, Oct 26, 2015</time>
      <h2 class="title">Refactoring-6-Replace Inheritance with Delegation</h2>
      <div class="summary">Replace Inheritance with Delegation, 这种重构方式主要是继承有时 看起来不是那么合理，同时继承可能让程序的扩展性不好，所以可以改用委托 或者组合的形式重构。 代码实例 Refactor前: public class Sanitation { public String washHands(){ return &quot;Cleaned!&quot;; } } class Child extends Sanitation{ public static void main(String[] args) { System.out.println(new Child().washHands()); } } Refactor之后: 把继承关系拿掉，才有委托的方式: class ChildRefactor{ Sanitation s; public ChildRefactor() { s = new Sanitation(); } public String washHands(){ return s.washHands(); } } 好处的思考 逻辑上Sanitation(公共卫生)和Child没有那种继承关系,修改之后表达更加准确 Child的washHand方法实际更加灵活了 更加容易通过使用Dependency Injection注入</div>
    </div>
  </a>
</article>

          </div>
          
          <div class="col-sm-6">
            <article class="li">
  <a href="http://testless.github.io/posts/refactoring/2015-10-26-refactoring-Extract-Interface-Method/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/3.jpg);"></div>
    <div class="detail">
      <time>Mon, Oct 26, 2015</time>
      <h2 class="title">Refactoring-7-Extract-Interface,Method,Sub Class,Supper Class</h2>
      <div class="summary">Extract-Interface,Method,Sub Class,Supper Class 以上重构的方式主要是通过提起接口,方法,为了让代码有更好的可读性,可测性. 开始:实例代码 以下是一个需要重构的实例代码： public class Receipt { private List&lt;Double&gt; discounts= Lists.newArrayList(); private List&lt;Double&gt; itemTotals=Lists.newArrayList(); public double calculateGradTotal(){ double subTotal =0; for (Double itemTotal : itemTotals) { subTotal+=itemTotal; } if(discounts.size()&gt;0){ for (Double discount : discounts) { subTotal-=discount; } } double tax=subTotal*0.065; subTotal+=tax; return subTotal; } } 抽取方法 阅读代码,根据计算方法的步骤,可以通过如下尝试抽取方法: - calculateSubTotal - calculateDiscounts - calculateTax 最后calculateGrandTotal 调用着三个方法. 由于实例代码比较简单,所以还看不出有多少优点. 但是如果想像calculateGrandTotal这个方法是很长的话，那么通过这种方式重构可以让计算calculateGrandTotal 的逻辑更加清晰. public double calculateGrandTotal(){ double subTotal=calculateSubTotal(); subTotal=calculateDiscounts(subTotal); subTotal=calculateTax(subTotal); return subTotal;</div>
    </div>
  </a>
</article>

          </div>
          
          <div class="col-sm-4">
            <article class="li">
  <a href="http://testless.github.io/posts/automation/2015-10-24-phantomjs-usage/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/6.jpg);"></div>
    <div class="detail">
      <time>Sat, Oct 24, 2015</time>
      <h2 class="title">Phantomjs Tutorial</h2>
      <div class="summary">自己学习Phatomjs的教程,分享之. Quick Start 首先phantomjs是个什么? 以下是官方网站的解释: PhantomJS is a headless WebKit scriptable with a JavaScript API. It has fast and native support for various web standards: DOM handling, CSS selector, JSON, Canvas, and SVG. phantomjs可以用来做什么? HEADLESS WEBSITETESTING SCREENSHOT PAGE AUTOMATION NETWORK MONITORING &hellip;&hellip; depends on your imagination 这里主要来介绍一下PhantomJS的基础用法,包括了: 基础语法 HEADLESS WEB TESTING SCREEN Capture Network Monitoring Page Automation 安装PhantomJS请参考: http://phantomjs.org/download.html 基础语法 Hello World console.log('Hello World!'); phantom.exit(); result: phantomjs hello_world.js Hello World! Page Loading 一下代码是访问百度首页,计算页面加载时间并且截屏的例子: var page = require('webpage').create(); var url = 'http://www.baidu.com'; t = Date.now(); page.open(url, function (status) { console.log(&quot;Status:&quot; + status); if (status !== 'success') { console.log('FAIL to load the address'); } else { t = Date.now() - t; console.log('Loading ' + url); console.log('Loading time ' + t + ' msec'); page.render('baidu.png'); //capture the screenshot } phantom.exit(); }) 运行结果： ●✚  phantomjs pageload.js [10:43:41] Status:success Loading http://www.baidu.com Loading time 699 msec 是不是很简单，只要几行代码就可以实现了,这里主要使用了:webpage 这个模块 Code Evaluation 通过evaluate 方法可以在当前页面运行js程序，但是也仅限于当前页面的范围 var page = require('webpage').create(); page.onConsoleMessage = function(msg) { console.log('Page title is ' + msg); }; page.open(&quot;http://www.baidu.com&quot;, function(status) { page.evaluate(function() { console.log(document.title); var element = document.getElementById('kw'); console.log(element.getAttribute('name')); }); phantom.exit(); }); 运行结果： phantomjs code_evaluation.js [10:51:55] Page title is 一张网页，要经历怎样的过程，才能抵达用户面前？ 一位新人，要经历怎样的成长，才能站在技术之巅？ 探寻这里的秘密； 体验这里的挑战； 成为这里的主人； 加入百度，加入网页搜索，你，可以影响世界。 Page title is 请将简历发送至 %c ps_recruiter@baidu.com（ 邮件标题请以“姓名-应聘XX职位-来自console”命名） color:red Page title is 职位介绍：http://dwz.cn/hr2013 Page title is 百度一下，你就知道 Page title is wd On request and Response 通过phantomjs 监听request和response，代码： var page = require('webpage').create(); var url=&quot;http://www.baidu.com&quot; page.onResourceRequested = function(request) { console.log('Request ' + JSON.stringify(request, undefined, 4)); }; page.onResourceReceived = function(response) { console.log('Receive ' + JSON.stringify(response, undefined, 4)); }; page.open(url,function(){ console.log(&quot;success&quot;); phantom.exit() }); 运行结果： ...............</div>
    </div>
  </a>
</article>

          </div>
          
          <div class="col-sm-4">
            <article class="li">
  <a href="http://testless.github.io/posts/true_stories/2015-10-24-return-flag/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/27.jpg);"></div>
    <div class="detail">
      <time>Sat, Oct 24, 2015</time>
      <h2 class="title">True Stories: About Return Flag</h2>
      <div class="summary">Return Flag 真实的一段代码片段： public boolean update(Inquiry inquiry) { boolean bUpdBaseInf = super.update(inquiry); solrService.syncUpdate(new SolrInquiry(inquiry.getInquiryId())); return bUpdBaseInfo; } 自己的思考： 这个返回的状态值没有完全体现整个函数的状态 如果solrService是个异步还可以理解这个返回值，但是名字是syncUpdate 直接是不是应该怀疑这是个异步更新？ solr的更新真的需要同步吗？solr的更新可能直接影响到整个业务的处理了&hellip;&hellip; 这里也许是留了点坑关于这个flag的 这个flag的命名是不是有点那个啥? 代码REVIEW 流程的思考 这样的代码,个人觉得代码REVIEW是需要检查出来的。也许这样的代码永远也不会出现问题，但是他的味道就是不好。 就算我是一个测试，也看出这里面不严谨的地方了,很多时候我们总是讲流程,流程，流程，但是有了流程又怎么样呢？ 一个好的技术团队是有他自己的品味的.呆过技术很好的公司,也呆过技术比较一般的公司,比较不同类别公司的开发， 很好的公司的开发更加注重这些细节,你可能觉得他们其实都在写差不多的代码,但是这种细节的常年累积,一个产品是否好维护就会出现很明显的差距了. 不容易维护的产品,有时可能已经资不抵债了. 如果想的更远一点的话,关于开发经常说到的工作无聊没有挑战的话题， 好公司的开发说的工作无聊和一般公司一些开发说的工作无聊可能是两个不同层次的无聊。 有些知道确实没有挑战而有些只是不知道其实自己写的代码挺烂的而已。我无意攻击任何人只是说说我真实的想法。</div>
    </div>
  </a>
</article>

          </div>
          
          <div class="col-sm-4">
            <article class="li">
  <a href="http://testless.github.io/posts/true_stories/2015-10-24-interesting-methods/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/26.jpg);"></div>
    <div class="detail">
      <time>Sat, Oct 24, 2015</time>
      <h2 class="title">True Stories: 有趣的函数</h2>
      <div class="summary">有趣的函数 下面是一些有趣而真实的函数，自己的感受是： 此刻的想法是复杂的 不敢想象 这是认真的吗? 为什么会这样? 如果4个key－value对是不是还要再写函数？ 这样的代码放在Controller层？你是认真的吗？ 测试有时真的很难改变什么,这样的代码其实已经无力吐槽了. // json方法 public String json(Map&lt;String,Object&gt; map){ JsonString jsonString = new JsonString(); Set&lt;String&gt; set = map.keySet(); for (String key : set) { //spring内置的对象去掉 if (key.contains(&quot;org.springframework&quot;)) { continue; } jsonString.put(key, map.get(key)); } return jsonString.toString(); } public String json(Model model){ return json(model.asMap()); } public String json(String key, Object value){ return new JsonString().put(key, value).toString(); } public String json(String key, Object value,String key2, Object value2){ return new JsonString().put(key, value).put(key2,value2).toString(); } public String json(String key, Object value,String key2, Object value2,String key3, Object value3){ return new JsonString().put(key, value).put(key2,value2).put(key3, value3).toString(); } 自己的思考 JOSN转换方法不应该放到Controller层 这几个json的函数其实没有必要,完全可以通过 使用了keySet,再使用map.get(key) 有点浪费，应该直接使用Map.Entry Map 转Json应该直接使用第三方库 不理解org.springframework的东西怎么会到Map里面？ new JsonString().put(key,value).put(key,value).toString(); 来获得，完全没有必要写这些函数，这些函数基本上和上面代码没有区别.</div>
    </div>
  </a>
</article>

          </div>
          
          <div class="col-sm-4">
            <article class="li">
  <a href="http://testless.github.io/posts/designpattern/2015-10-22-Functional-Programming-pattern/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/12.jpg);"></div>
    <div class="detail">
      <time>Fri, Oct 23, 2015</time>
      <h2 class="title">Functional Patterns</h2>
      <div class="summary">记录一个关于函数式设计模式 Functional patterns Core Principles of FP design Functions Types Composition Functions as parameters Abstraction,Dependency injection Partial application, Continuations,Folds Chaining Functions Error handling, Async Monads Dealing with wrapped data Lifting,Functors Validation with applicatives Aggregating data and operations Monoids Functional programming is scary Functors applicatives currying catamorphism Monad Monoid chainable aggregatable mappable Object oriented programming is scary Generic Polymorphism Interface Inheritance SOLID: SRP,OCP,LSP,ISP,DIP,&hellip;&hellip; Covariance IOC,DI,MVC OO Patterns VS FP Patterns OO pattern/principle • Single Responsibility Principle • Open/Closed principle • Dependency Inversion Principle • Interface Segregation Principle • Factory pattern • Strategy pattern • Decorator pattern • Visitor pattern FP pattern/principle • Functions • Functions • Functions, also • Functions • Yes, functions • Oh my, functions again!</div>
    </div>
  </a>
</article>

          </div>
          
          <div class="col-sm-4">
            <article class="li">
  <a href="http://testless.github.io/posts/interview/2015-10-22-python_interview_questions/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/20.jpg);"></div>
    <div class="detail">
      <time>Thu, Oct 22, 2015</time>
      <h2 class="title">Python 面试题</h2>
      <div class="summary">测试有的时候出去会遇到一些编程面试题,以下是用python来解决两个简单面试题. 倒转字符串中的单词的排列 给定字符串“Hello World!”,经过一段程序运行之后,得到输出结果“World! Hello”,也就是以单词 为单位,倒转输入“Hello World!” python解法: 不考虑编码格式 words = &quot;Hello World!&quot; print(&quot; &quot;.join(reversed(words))) print(&quot; &quot;.join(words.split(&quot; &quot;)[::-1])) Java 解法 public class ReverseWords { public static String reverseWords(String input){ String[] words = input.split(&quot; &quot;); StringBuilder sb = new StringBuilder(); for (int i = words.length-1; i &gt;=0 ; i--) { sb.append(words[i]); sb.append(&quot; &quot;); } return sb.toString().trim(); } public static void main(String[] args) { System.out.println(reverseWords(&quot;Hello World!&quot;)); } } 输出斐波那契数列 根据给定的值,输出相同数目的斐波那契列， 如如果给定是1， 则输出1;给定2,输出1,1;</div>
    </div>
  </a>
</article>

          </div>
          
          <div class="col-sm-4">
            <article class="li">
  <a href="http://testless.github.io/posts/thoughts/2015-10-22-Random-TestCaseDesign/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/25.jpg);"></div>
    <div class="detail">
      <time>Thu, Oct 22, 2015</time>
      <h2 class="title">测试用例设计- 随机指定一个产品的测试</h2>
      <div class="summary">有时面试的时候会随机指定一个产品进行测试,比如一个电梯,你会如何设计测试用例？这个问题很发散,更多的是看应聘者的条理 和分析能力. 本质上一个电梯是一个太大的范畴，实际测试的过程中很少一下子会有这么巨大的功能让你测试的。 与其说让你设计测试用例，其实好不如说让你想一个电梯有什么功能,然后根据功能再来考虑测试用例,所以更多的 是考察思路,在实际的测试工作中,如果突然有个人说我今天完成了一个电梯的功能,找个人给我测一下吧。 那么多半这个项目就是个让测试欲哭无泪的项目。 不过既然面试有人问这样的问题，那么就分析分析吧，以下我是把电梯转化为类似互联网产品来做的分析， 完全是个人想法,一定有非常多欠缺。 后端服务组件和客户端分离(Client-Server/MVC) 首先其实对把一个电梯分成不同的组件： 驱动服务: 可以使电梯上下行(后台服务) 门: 开门关门(后台服务) 电梯操作面板: 人机界面,担当用户和电梯的一个中间人作用,将用户操作转化为指令来控制电梯 (app/web page) (如果简单的话可能操作命令转换就都在这个地方了，如果复杂可能还有一个控制系统层) 指令控制系统(调度系统,监听器或者Queue) 呼叫监控系统:(可以暂时不考虑) 这里就先考虑简单的情况，电梯操作面板模块之内将操作转换成指令给电梯的驱动和门服务 逐个组件来考虑用例 驱动服务可能包含的功能点有如下: 上行, 但是上行有极限位置(可配置)，按照指定步进数量上行 中途等待 步进距离(一层距离)可以配置 下行,下行位置(可配置)，按照指定步进数量下行 承载重量 可靠性监测，使用寿命监测 故障监测 这里注意如果测试电梯产品和测试指定某个大楼的电梯,测试用例的设计考虑点是稍有不同的，如果是电梯产品他就有电梯的配置项需要测试， 如果是测试制定电梯,那么配置项就可以忽略了，配置的就是你目前的配置。 门服务 关于门的服务可能会想到的是: 开门 关门 可靠性 对于开门这个功能的测试用例测试可以围绕: 接收到开门指令开门并且只做开门 在电梯运动过程中接收到开门指令不开门 接收不到开门指令则不开门 开门指令被中断 开门接到后的进行开门的响应时间 关门是类似，但是关门需要考虑超重情况下不能关门. 可靠性考虑多少次开门关门之后开门关门的机械组件才失效 电梯操作面板 操作面板这块实际上分为界面控件状态改变和指令转换两大块,在通过操作操作面板按钮后，同时 改变按钮状态以及发送正确指令,而指令处理这块就可 - 门开关按钮, 开关有效,开关无效 - 楼层按钮，启用,取消，灯亮，灯关 - 电梯上下调度, 多个按钮被按下之后,结合电梯自己所在位置决定运行方案 - 易用性等，因为是见人的地方，所有就有usability 测试 指令控制系统 指令控制系统可以认为根据电梯运行时的上下文,调度电梯运行的一个模块,这里面应该是根据某种规则 发出实际控制电梯的信号，具体什么的规则其实很难断定。 扩展到多个电梯的调度测试 有可能会有多个电梯的调度，同样也是需要一套规则再来进行测试的 这个文章写的有点粗糙,主要凭空去想这些case太伤脑袋，但是总体而言个人认为这是一个考虑问题的方向，同时个人觉得在一个短时间内 针对这样一个系统说写出很多测试用例，其实也就是呵呵了。 也许有更好的方法来总结这样的测试,可能类似于探索性测试之类的，希望有人能够指正。 同时我们也可以看到设计测试用例要包含多少东西,测试需要了解: 产品需求(没有需要推测:)) 功能 可靠性 性能 扩展性 可用性 从high level看可能还有更多,这些一个人都可以搞定的话,这个人还是人吗?而在实际的工作中这些会有都 多少人都进行相关类型的测试？不说进行这样的测试，估计连衡量这些测试的优先级都不会,有人说的头头 是道，可是真的有多少实践呢？ 生活可能就是这样的,说的天花乱坠的,可能其实都是别人的经验,如果真的自己动手做的时候,就说需要找人做.</div>
    </div>
  </a>
</article>

          </div>
          
        </div>
      </div>

      
<nav class="paging">
  
  <a href="/page/5" class="left" rel="prev">PREV</a>
  

  
  <a href="/page/7" class="right" rel="next">NEXT</a>
  
</nav>



    </div>

    <div class="col-sm-3">
      <aside class="site">

  

  

  <div class="section">
    <header><div class="title">LatestPosts</div></header>
    <div class="content">
      
      <div class="sm"><article class="li">
  <a href="http://testless.github.io/posts/python/2016-04-17-python-tricky-01/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/18.jpg);"></div>
    <div class="detail">
      <time>Sun, Apr 17, 2016</time>
      <h2 class="title">Python Tricky-01</h2>
      <div class="summary">Python Tricky python tricky 是记录一些Python使用过程中一些神奇的小技巧. Argument Unpacking 一个argument unpacking的例子： def product(a, b): print(&quot;a is %d&quot; % a) print(&quot;b is %d&quot; % b) return a * b argument_tuple = (1, 2) argument_dict = {'a': 1, 'b': 2} argument_list = [1,2] # interesting for unpacking print(product(*argument_list)) print(product(*argument_tuple)) print(product(**argument_dict)) python unpacking 这里指的是调用python函数的参数可以自动匹配： list: 顺序匹配函数参数，变量调用时以*开始 tuple：顺序匹配函数参数，变量调用时以*开始 dict: 根据key值来匹配，变量调用时以**开始 下面是一个可扩展unpacking的方式： *其实表示一个list &quot;&quot;&quot;allows collecting not explicitly assigned values into a placeholder variable&quot;&quot;&quot; a, *b, c = range(10) print(a, b, c) &quot;&quot;&quot;advanced example&quot;&quot;&quot; [(c, *d, [*e]), f, *g] = [[1, 2, 3, 4, [5, 5, 5]], 6, 7, 8] print(c, d, e, f, g) bool python 中的bool有True or False，python2中的True 或者False都可以改变对应的值： python中的True or False可以参加数学运算： a = 5 print(isinstance(a,int)+(a&lt;10)) # interesting writing print([&quot;is odd&quot;,&quot;is even&quot;][a % 2 ==0]) print(&quot;is even&quot; if a % 2 ==0 else &quot;is odd&quot;) python中循环如果使用True会比使用1来的慢，不过一般肯定是使用True or False来做循环的： from timeit import timeit def test_true(): count = 100 while True: # Here is True if count &lt; 0: break count = -1 def test_1(): count = 100 while 1: break count -= 1 print('use True: %s' %timeit(test_true, number=1000000)) print('use 1: %s' % timeit(test_1, number=1000000)) 结果： use True: 0.21380468501592986 use 1: 0.1610587630129885 Property Cache python 的property可以通过__get__来获取，同时可以在运行时添加，改变属性的值 class PropertyCache: &quot;&quot;&quot; a decorator to cache property &quot;&quot;&quot; def __init__(self, func): self.func = func def __get__(self, obj, cls): if not obj: return self value = self.func(obj) # Magic Here, there is property_to_be_cached property there setattr(obj, self.func.__name__, value) return value class Foo: def __init__(self): self._property_to_be_cached = 'result' @PropertyCache def property_to_be_cached(self): print('compute') return self._property_to_be_cached test = Foo() print(test.property_to_be_cached) print(test.property_to_be_cached) print(Foo().property_to_be_cached) 这里通过一个装饰器：PropertyCache 来装饰property_to_be_cached，在调用property_to_be_cached时，其实是通过PropertyCache的get来获取，那么： value = self.func(obj) 就是通过调用Foo中的property_to_be_cached函数，value就是property_to_be_cached的返回值 setattr(obj, self.func.name, value)： 就是将value付给了属性：property_to_be_cached，self.func.name 其实就是property_to_be_cached 这是一个挺有意思的例子来说明了动态语言的一些magic的方法 calculator 这里例子可以看出，python的函数的一些使用方法，函数也可以作为一种参数，活着变量 import operator ops = { &quot;+&quot;: operator.add, &quot;-&quot;: operator.sub, &quot;/&quot;: operator.truediv, &quot;*&quot;: operator.mul } x = input(&quot;Enter an operator [OPTIONS: +, -, *, /]: &quot;) y = int(input(&quot;Enter number: &quot;)) z = int(input(&quot;Enter number: &quot;)) # interesting to use function print (ops[x](y, z)) chained comparsion a = 10 print(1 &lt; a &lt; 50) print(10 == a &lt; 20) compile python 可以通过exec可以直接运行组装起来的字符串，当然其实很多语言都可以的&hellip;&hellip; import math # using sin, cos and sqrt for example ''' Takes a code string and returns a ready-to-use function ''' def compile_(s): code = &quot;&quot;&quot;def f(x):\n return {}&quot;&quot;&quot;.format(s) # wrap the string as a function f(x) scope = {&quot;sin&quot;: math.sin, &quot;cos&quot;: math.cos, &quot;sqrt&quot;: math.sqrt} # define the scope for the code to use exec(code, scope) # execute code inside the given scope # f(x) gets defined inside %vis% return scope[&quot;f&quot;] # now we only have to extract it and return f = compile_(&quot;x**2 + 2*sin(x)&quot;) print(f(10)) &quot;&quot;&quot;exec can be used to execute Python code during runtime variables can be handed over as a dict &quot;&quot;&quot; exec(&quot;print('Hello ' + s)&quot;, {'s': 'World'}) sequence sequence 其实是个list，如果遍历这个list，遍历时需要进行一些调用的话，那么下面例子提供了两个不同的方法.</div>
    </div>
  </a>
</article>
</div>
      
      <div class="sm"><article class="li">
  <a href="http://testless.github.io/posts/python/2016-04-17-python-tricky-02/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/10.jpg);"></div>
    <div class="detail">
      <time>Sun, Apr 17, 2016</time>
      <h2 class="title">Python Tricky-02</h2>
      <div class="summary">Python Tricky-2 max split &quot;&quot;&quot;split a string max times&quot;&quot;&quot; string = &quot;a_b_c_d_e&quot; print(string.split(&quot;_&quot;, 2)) &quot;&quot;&quot;use maxsplit with arbitrary whitespace&quot;&quot;&quot; s = &quot;foo bar foobar foo&quot; print(s.split(None, maxsplit=1)) min and max index 获取最大值，最小值的index &quot;&quot;&quot; Find Index of Min/Max Element. &quot;&quot;&quot; lst = [40, 10, 20, 30] def minIndex(lst): return min(range(len(lst)), key=lst.__getitem__) # use xrange if &lt; 2.7 def maxIndex(lst): return max(range(len(lst)), key=lst.__getitem__) # use xrange if &lt; 2.7 print(minIndex(lst)) print(maxIndex(lst)) nested function python 支持函数作为参数传递： &quot;&quot;&quot;nested functions&quot;&quot;&quot; def addBy(val): print(val) def func(inc): print(inc) return val + inc return func addFive = addBy(5) print(addFive(4)) addThree = addBy(3) print(addThree(7)) obj get attribute 通过getattr获取python的属性，可以是类级别的，也可以实例级别的，但是如果属性没有实例级别是先通过__getattribute__获取 class obj(): attr = 1 def __getattribute__(self, item): print('get attribute') return &quot;123&quot; def __get__(self, instance, owner): print(&quot;get&quot;) def __getattr__(self, item): print(&quot;get attribute1&quot;) foo = &quot;attr&quot; a = obj() print(a.test) print(getattr(obj, foo)) print(getattr(a, &quot;attr1&quot;)) remove duplicated values 这里面需要理解清楚的是： list，可以重复 set,没有重复 &quot;&quot;&quot;remove duplicate items from list.</div>
    </div>
  </a>
</article>
</div>
      
      <div class="sm"><article class="li">
  <a href="http://testless.github.io/posts/designpattern/2016-04-11-singleton/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/singleton.jpg);"></div>
    <div class="detail">
      <time>Mon, Apr 11, 2016</time>
      <h2 class="title">Java Singleton ENUM as instance HOLDER</h2>
      <div class="summary">Singleton 单例设计模式 单例模式是产生一个类的唯一实例。 Java Singleton Java 的Singleton实际上有很多种写法的，下面一个是使用枚举方式写的： public class InitializingOnDemandHolderIdiom implements Serializable { private static final long serialVersionUID = 1L; private static class HelperHolder { public static final InitializingOnDemandHolderIdiom INSTANCE = new InitializingOnDemandHolderIdiom(); } public static InitializingOnDemandHolderIdiom getInstance() { return HelperHolder.INSTANCE; } private InitializingOnDemandHolderIdiom() { } protected Object readResolve() { return getInstance(); } }</div>
    </div>
  </a>
</article>
</div>
      
      <div class="sm"><article class="li">
  <a href="http://testless.github.io/posts/designpattern/2016-04-11-prototype-pattern/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/prototype.png);"></div>
    <div class="detail">
      <time>Mon, Apr 11, 2016</time>
      <h2 class="title">Prototype Pattern</h2>
      <div class="summary">prototype pattern 实际上是通过clone的方式创建出同一个类的不同对象. Java Prototype 一般Prototype模式中，又一个prototype的抽象类： public abstract class Prototype implements Cloneable{ @Override protected abstract Object clone() throws CloneNotSupportedException; } 这个抽象类的不同子类： public abstract class Beast extends Prototype { @Override public abstract Beast clone() throws CloneNotSupportedException; } public class ElfBeast extends Beast { public ElfBeast() { } public ElfBeast(ElfBeast beast) { } @Override public Beast clone() throws CloneNotSupportedException { return new ElfBeast(this); } @Override public String toString() { return &quot;Elven eagle&quot;;</div>
    </div>
  </a>
</article>
</div>
      
      <div class="sm"><article class="li">
  <a href="http://testless.github.io/posts/shell/2016-04-05-VIM-%E6%80%BB%E7%BB%93/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/vim.png);"></div>
    <div class="detail">
      <time>Tue, Apr 5, 2016</time>
      <h2 class="title">VIM 使用小结</h2>
      <div class="summary">VIM 用法 日常会不经意间使用VIM编辑器来处理一些文本编辑的事情。所以整理VIM的基本使用如下： 命令 说明 q 退出 i insert a append h 左移 k 上移 j 下移 l 右移 r 替换 u 撤销 x 删除光标位置字符 d^ 删除当前位置到行首 dd 删除当前行 d$ 删除当前位置到行尾 dw 删除当前位置到一个word尾 3dd 删除当前行下三行 p 粘贴 &lt;&lt; 当前行左移一个宽度 &gt;&gt; 当前行右移一个宽度 ％ 匹配的括号 ^ 行的开始 . 匹配单字符 * 匹配0个或多个之前的字符 $ 行的结束 [ 还是一系列的匹配 &lt;&gt; 一个字的结束或开始,/&lt;the&gt; 只匹配the f 向右移动到指定字符 F 向左移动到指定字符 ctrl+b 向后回滚一页 ctrl＋d 向前滚动半个窗口 ctrl＋F 向前滚动一页 ctrl＋H 左移一个空格 ctrl＋J 下移一个空格 ( 移动到句子开头 ) 移动到句子句尾 { 前一个段落 + 下一行非空字符 - 前一行非空字符 _ 当前行的非空字符 其他命令 y和d的作用类似，不同的是y只提取文字而不删除文字 缩写：ab test &ldquo;testing in tesitng&rdquo; mapping, :map,:map!</div>
    </div>
  </a>
</article>
</div>
      
      <div class="sm"><article class="li">
  <a href="http://testless.github.io/posts/automation/2016-03-30-ansible_basic/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/ansible.png);"></div>
    <div class="detail">
      <time>Wed, Mar 30, 2016</time>
      <h2 class="title">Ansible简单介绍</h2>
      <div class="summary">Ansible 介绍 Ansible 目前都是使用在python2上面. installation 在MAC 上面安装ansible有两种方式： pip pip install ansible brew brew install ansible ansible playbook 的简单使用 ansible 大概的一个框架图如下： 下面简单介绍一个使用ansible的例子： 配置hosts文件 在当前目录创建一个hosts文件： [jenkins] 192.168.3.50 配置ansible yml playbook文件 配置当前一个yml文件: - hosts: jenkins user: root accelerate:true tasks: - name: restart_nginx shell: sh /root/auto_publish_qadoc.sh 运行命令 ansible-playbook playbook.yml -i hosts -vv 就可以运行这些命令了,最简单的ansible就是这样上手非常容易. 不过仔细看看他的帮助文档的话，其实对于python不熟的人还是会有一定难度，不过如果写过程序的人，写过python东西的人来说，其实 过一下这个document估计也就是1天时间就可以上手干活了.</div>
    </div>
  </a>
</article>
</div>
      
      <div class="sm"><article class="li">
  <a href="http://testless.github.io/posts/automation/2016-03-30-jenkins_basic/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/jenkins.png);"></div>
    <div class="detail">
      <time>Wed, Mar 30, 2016</time>
      <h2 class="title">Jenkins API的简单介绍</h2>
      <div class="summary">Jenkins 介绍 Jenkins是一个非常有用的持续集成的工具，可以通过它完成代码的build，测试，发布等一系列的事情. From Jenkins Home Page Jenkins is an automation engine with an unparalleled plugin ecosystem to support all of your favorite tools in your delivery pipelines, whether your goal is continuous integration, automated testing, or continuous delivery. Jenkins 使用 关于Jenkins的基本使用网上有很多的教程，基本使用其事没有太多说的，它是个平台，可以集成很多不同的工具，脚本等等. 总结下来这些东西包括： jenkins parameter setting, string, choice, &hellip;&hellip; JAVA 的maven, ant, gradle 等打包工具，其他语言也有类似的build，deploy，依赖管理的工具 定制化的脚本，可以在一个Jenkins的build步骤中运行这些脚本如shell命令，python脚本 定制插件来完成自己的特殊的目的 这些内容非常庞大，自己也不可能完全都知道，如果遇到实际的一些问题需要解决的话, 大体的逻辑就是，如果遇到一些特殊需求，那么先去找插件看能不能完成，如果没有插件就再想shell，python脚本等不同的事情，或者自己开发插件. Jenkins 的实践问题 随着Jenkins里面的任务越来越多，管理的环境越来越多，变更越来愈多，手工管理就会遇到一些问题： 比如为了改一个IP地址，可能需要没一个任务都去改具体的配置，比如部署同一个war到不同的测试环境，就需要给不同的job改IP 为了不同的环境配置不同的任务，需要很多的人工的配置修改等等 如果需要迁移一个多应用的测试环境，那么需要很多的复制，修改工作 那么为了解决这些问题，个人觉得可以改善的地方是： - 定义一些类型项目的模版，抽象一些参数出来给Jenkins里面的Job做参数话，当然有时需要修改的是默认值 - 在定义了一些模版之后，就可以通过操作Jenkins API的方式来操作 - 在尝试了一些Jenkins API之后，感觉纯粹通过API的方式去操作，不一定比复制Jenkins 任务，然后修改来的快，但是通过Jenkins API的方式 来操作Jenkins 的好处是，如果这些东西融入到运维的流程中，那么它会提高生产率 一些体会是，可能代码方式的操作单个单个来看不一定会提高多少生产率(参数一样要设)，但是如果放在一个流程的角度看，那么他的效率是高的，比如你如果需要运维帮你建环境，那么你需要提供一些信息，而这些信息就可以直接建立Jenkins的Job了，那么作为用户你只提供一次信息，就可以完成你需要的所有事情，这样效率就高了.</div>
    </div>
  </a>
</article>
</div>
      
      <div class="sm"><article class="li">
  <a href="http://testless.github.io/posts/python/2016-02-28-python_oop_attributes/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/7.jpg);"></div>
    <div class="detail">
      <time>Sun, Feb 28, 2016</time>
      <h2 class="title">Python 面向对象，以及访问对象属性基础</h2>
      <div class="summary">在前面的Zabbix API调用中我们看到了python的__getattr__的妙用，下面就探索一下这里面的道理,所以就聊聊python面向对象的基础知识. Python 面向对象 说到面向对象，就会说到类(class)，对象(object),那么什么是Class，Object呢？ Object： Objects have states and behaviors. Example: A dog has states - color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class. Class: A class can be defined as a template/blue print that describes the behaviors/states that object of its type support. 那么综合起来，class就是用来描述一系列对象的一个模版，抽象出了共同的东西(class)，object就是具体的某种情况下的一个例子(instance) 面向对象有如下基础概念： Polymorphism Inheritance Encapsulation Abstraction Classes Objects Instance Method Message Parsing Python Class and Object 的使用 看下例： - class Dog 定义了一个类 - __init__ 构造这个类的方法，就是创建出一个Dog的对象是通过这个方法 - name, 类的一个属性;eat(),也可以看成是类的一个属性，实际上它是一个dog的一个行为(behavior) - dog = Dog() 是创建了一个Dog(class)的新的的对象(object), 按照我们上面说的，dog是类Dog(class)的一个实例(instance) class Dog: def __init__(self): self.name='dog' def eat(): print('eating......') dog = Dog() print(dog.name) Python 对象的创建 参考上例，分别来说明对象的创建，访问.</div>
    </div>
  </a>
</article>
</div>
      
      <div class="sm"><article class="li">
  <a href="http://testless.github.io/posts/python/2016-02-28-simple_word_count/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/18.jpg);"></div>
    <div class="detail">
      <time>Sun, Feb 28, 2016</time>
      <h2 class="title">Simple Word Counter</h2>
      <div class="summary">有时测试的面试题中会考点编程的内容，比如统计字符串中的相同字符数量，具体题目如下： 给定一个字符串，如MIssissippi 计算字符串中每一个不同字符出现的数量 Python 的解法 letter_count={} for letter in 'MIssissippi': letter[letter]=letter_count.get(letter,0)+1 print(letter_count) 运行结果： {'s': 4, 'M': 1, 'i': 3, 'I': 1, 'p': 2} Java 的解法 JAVA 8 中给Map加入了getOrDefault的方法，下面就分别介绍一下JAVA8之前和使用JAVA8的方法： JAVA8 之前： public Map&lt;String,Integer&gt; countCharacters(String source){ char[] chars = source.toCharArray(); Map&lt;String,Integer&gt; result = new HashMap&lt;&gt;(); for (char aChar : chars) { Integer existing_counter = result.get(String.valueOf(aChar)); int counter = existing_counter==null?0:existing_counter; result.put(String.valueOf(aChar),counter+1); } return result; } JAVA8 解法 public Map&lt;String,Integer&gt; countCharacters_JAVA8(String source){ char[] chars</div>
    </div>
  </a>
</article>
</div>
      
      <div class="sm"><article class="li">
  <a href="http://testless.github.io/posts/python/2016-02-26-call_zabbix_api/" class="clearfix">
    <div class="image" style="background-image: url(http://testless.github.io/images/10.jpg);"></div>
    <div class="detail">
      <time>Fri, Feb 26, 2016</time>
      <h2 class="title">Python 访问Zabbix API</h2>
      <div class="summary">Zabbix API 访问 准备使用Python来访问一下Zabbix，首先当然阅读一下Zabbix的API Manual,抛开什么json rpc这样的问题之外，zabbix的API的分类还是很工整的，所以看起来比较舒服，在一定了解了zabbix基础之后，基本上就可以上手来写了，网上查了一下，找个一个python zabbix的调用的一个客户段代码，感觉不错，就开始行动了。 Zabbix API 客户端代码的实现 Zabbix API的主要的两个参数其实是method，params，params基本上就可以看作一些可变的参数，其实就是一个json或者map， 对于method来说，一般就是 resource.action 这种方式，所以python客户端使用重写了一个getattr来做,返回一个可以访问不同资源名称的客户端,具体的代码如下： class ZabbixClient: &quot;&quot;&quot; Generic Zabbix API Client - login - get auth &quot;&quot;&quot; globale_header = { &quot;Content-Type&quot;: &quot;application/json-rpc&quot; } def __init__(self, session=None, timeout=None): self.user_name, self.default_user_name = '1', '1' self.password, self.default_password = '123456', '123456' self.zabbix_api_url = 'http://{0}/api_jsonrpc.php'.format('abcd.http') if session: self.session = session else: self.session = requests.session() self.session.headers.update({ 'Content-Type': 'application/json-rpc', 'User-Agent': 'python-zabbix-client', 'Cache-Control': 'no-cache' }) self.auth = '' self.id = 0 self.timeout = timeout logger.info('JSON-RPC Server EndPoint: %s', self.zabbix_api_url) def login_in(self, user_name=None, password=None): &quot;&quot;&quot; login with given user_name and password, if None, use default user :param user_name: :param password: :return: result,auth key &quot;&quot;&quot; if user_name: self.user_name = user_name if password: self.password = password self.auth = self.user.login(user=self.user_name, password=self.password) def api_version(self): return self.apiinfo.version() # def confimport(self, format='', source='', rules=''): # &quot;&quot;&quot;Alias for configuration.import because it clashes with # Python's import reserved keyword&quot;&quot;&quot; # # return self.do_request( # method=&quot;configuration.import&quot;, # params={&quot;format&quot;: format, &quot;source&quot;: source, &quot;rules&quot;: rules} # )['result'] def do_request(self, method, params=None): request_json = { 'jsonrpc': '2.0', 'method': method, 'params': params or {}, 'id': self.id, } if method != 'apiinfo.version' and self.auth: request_json['auth'] = self.auth logger.debug(&quot;sending: %s&quot;, json.dumps(request_json, indent=4, separators=(',', ':'))) response = self.session.post( self.zabbix_api_url, data=json.dumps(request_json), timeout=self.timeout ) logger.debug(&quot;Response Code : %s&quot;, str(response.status_code)) response.raise_for_status() if not len(response.text): raise ZabbixAPIException(&quot;没有返回值&quot;) try: response_json = json.loads(response.text) except ValueError: raise ZabbixAPIException(&quot;不能解析JSON %s&quot; % response.text) logger.debug(&quot;sending: %s&quot;, json.dumps(request_json, indent=4, separators=(',', ':'))) self.id += 1 if 'error' in response_json: if 'data' not in response_json['error']: response_json['error']['data'] = 'No Data' msg = &quot;Error {code}: {message},{data}&quot;.format( code=response_json['error']['code'], message=response_json['error']['message'], data=response_json['error']['data'] ) raise ZabbixAPIException(msg, response_json['error']['code']) return response_json def __getattr__(self, item): &quot;&quot;&quot; auto create Zabbix API Client :param item: :return: &quot;&quot;&quot; return ZabbixAPIObjectClass(item, self) class ZabbixAPIObjectClass(object): def __init__(self, name, parent): self.name = name self.parent = parent def __getattr__(self, item): &quot;&quot;&quot; dynamic create a method (get,create,update,delete) :param item: :return: &quot;&quot;&quot; def fn(*args, **kwargs): if args and kwargs: raise TypeError('Found Both args and kwargs') return self.parent.do_request('{0}.{1}'.format(self.name, item), args or kwargs)['result'] return fn 基本上一个文件就搞定了，不过这个基本上参考了网上的一个代码实现的，这里使用getattr这种方式可以非常简洁的处理了这种请求非常类似的情况，这也是python的魅力吧.</div>
    </div>
  </a>
</article>
</div>
      
    </div>
  </div>

  
  <div class="section taxonomies">
    <header><div class="title">category</div></header>
    <div class="content">
      <a href="http://testless.github.io/categories/python">python</a><a href="http://testless.github.io/categories/refactoring">refactoring</a><a href="http://testless.github.io/categories/automation">automation</a><a href="http://testless.github.io/categories/shell">shell</a><a href="http://testless.github.io/categories/testing">testing</a><a href="http://testless.github.io/categories/designpattern">designpattern</a><a href="http://testless.github.io/categories/java">java</a><a href="http://testless.github.io/categories/microservice">microservice</a><a href="http://testless.github.io/categories/thoughts">thoughts</a><a href="http://testless.github.io/categories/truestories">truestories</a><a href="http://testless.github.io/categories/performance">performance</a><a href="http://testless.github.io/categories/tools">tools</a><a href="http://testless.github.io/categories/interview">interview</a><a href="http://testless.github.io/categories/ruby">ruby</a><a href="http://testless.github.io/categories/js">js</a><a href="http://testless.github.io/categories/git">git</a>
    </div>
  </div>
  
  <div class="section taxonomies">
    <header><div class="title">tag</div></header>
    <div class="content">
      <a href="http://testless.github.io/tags/python">python</a><a href="http://testless.github.io/tags/refactoring">refactoring</a><a href="http://testless.github.io/tags/automation">automation</a><a href="http://testless.github.io/tags/shell">shell</a><a href="http://testless.github.io/tags/testing">testing</a><a href="http://testless.github.io/tags/designpattern">designpattern</a><a href="http://testless.github.io/tags/java">java</a><a href="http://testless.github.io/tags/microservice">microservice</a><a href="http://testless.github.io/tags/thoughts">thoughts</a><a href="http://testless.github.io/tags/truestories">truestories</a><a href="http://testless.github.io/tags/performance">performance</a><a href="http://testless.github.io/tags/interview">interview</a><a href="http://testless.github.io/tags/tools">tools</a><a href="http://testless.github.io/tags/ruby">ruby</a><a href="http://testless.github.io/tags/git">git</a><a href="http://testless.github.io/tags/js">js</a>
    </div>
  </div>
  

</aside>

    </div>

  </div>
      </div>

    <footer class="site">
      <p>&copy; 2016 Colored Hedwig: less is more</p>
      <p>Powered by <a href="http://gohugo.io" target="_blank">Hugo</a>,</p>
      <p>Theme <a href="https://github.com/dim0627/hugo_theme_robust" target="_blank">Robust</a> designed by <a href="http://yet.unresolved.xyz" target="_blank">Daisuke Tsuji</a></p>
    </footer>

    <script src="//code.jquery.com/jquery-2.1.3.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    

  <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1258417648'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1258417648%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script>
  </body>
</html>

